// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library validation_test_interfaces_mojom;
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/mojom_types.mojom.dart' as mojom_types;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;

class BasicEnum extends bindings.MojoEnum {
  static const BasicEnum a = const BasicEnum._(0);
  static const BasicEnum b = const BasicEnum._(1);
  static const BasicEnum c = const BasicEnum._(0);
  static const BasicEnum d = const BasicEnum._(-3);
  static const BasicEnum e = const BasicEnum._(10);

  const BasicEnum._(int v) : super(v);

  static const Map<String, BasicEnum> valuesMap = const {
    "a": a,
    "b": b,
    "c": c,
    "d": d,
    "e": e,
  };
  static const List<BasicEnum> values = const [
    a,
    b,
    c,
    d,
    e,
  ];

  static BasicEnum valueOf(String name) => valuesMap[name];

  factory BasicEnum(int v) {
    switch (v) {
      case 0:
        return BasicEnum.a;
      case 1:
        return BasicEnum.b;
      case 0:
        return BasicEnum.c;
      case -3:
        return BasicEnum.d;
      case 10:
        return BasicEnum.e;
      default:
        return null;
    }
  }

  static BasicEnum decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    BasicEnum result = new BasicEnum(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum BasicEnum.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case a:
        return 'BasicEnum.a';
      case b:
        return 'BasicEnum.b';
      case c:
        return 'BasicEnum.c';
      case d:
        return 'BasicEnum.d';
      case e:
        return 'BasicEnum.e';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}



class StructA extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int i = 0;

  StructA() : super(kVersions.last.size);

  StructA.init(
    int this.i
  ) : super(kVersions.last.size);

  static StructA deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructA decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructA result = new StructA();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.i = decoder0.decodeUint64(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructA";
    String fieldName;
    try {
      fieldName = "i";
      encoder0.encodeUint64(i, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructA("
           "i: $i" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["i"] = i;
    return map;
  }
}


class StructB extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  StructA structA = null;

  StructB() : super(kVersions.last.size);

  StructB.init(
    StructA this.structA
  ) : super(kVersions.last.size);

  static StructB deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructB decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructB result = new StructB();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.structA = StructA.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructB";
    String fieldName;
    try {
      fieldName = "structA";
      encoder0.encodeStruct(structA, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructB("
           "structA: $structA" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["structA"] = structA;
    return map;
  }
}


class StructC extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<int> data = null;

  StructC() : super(kVersions.last.size);

  StructC.init(
    List<int> this.data
  ) : super(kVersions.last.size);

  static StructC deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructC decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructC result = new StructC();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.data = decoder0.decodeUint8Array(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructC";
    String fieldName;
    try {
      fieldName = "data";
      encoder0.encodeUint8Array(data, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructC("
           "data: $data" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["data"] = data;
    return map;
  }
}


class StructD extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<core.MojoMessagePipeEndpoint> messagePipes = null;

  StructD() : super(kVersions.last.size);

  StructD.init(
    List<core.MojoMessagePipeEndpoint> this.messagePipes
  ) : super(kVersions.last.size);

  static StructD deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructD decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructD result = new StructD();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.messagePipes = decoder0.decodeMessagePipeHandleArray(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructD";
    String fieldName;
    try {
      fieldName = "messagePipes";
      encoder0.encodeMessagePipeHandleArray(messagePipes, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructD("
           "messagePipes: $messagePipes" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructE extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  StructD structD = null;
  core.MojoDataPipeConsumer dataPipeConsumer = null;

  StructE() : super(kVersions.last.size);

  StructE.init(
    StructD this.structD, 
    core.MojoDataPipeConsumer this.dataPipeConsumer
  ) : super(kVersions.last.size);

  static StructE deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructE decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructE result = new StructE();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.structD = StructD.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.dataPipeConsumer = decoder0.decodeConsumerHandle(16, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructE";
    String fieldName;
    try {
      fieldName = "structD";
      encoder0.encodeStruct(structD, 8, false);
      fieldName = "dataPipeConsumer";
      encoder0.encodeConsumerHandle(dataPipeConsumer, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructE("
           "structD: $structD" ", "
           "dataPipeConsumer: $dataPipeConsumer" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructF extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<int> fixedSizeArray = null;

  StructF() : super(kVersions.last.size);

  StructF.init(
    List<int> this.fixedSizeArray
  ) : super(kVersions.last.size);

  static StructF deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructF decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructF result = new StructF();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.fixedSizeArray = decoder0.decodeUint8Array(8, bindings.kNothingNullable, 3);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructF";
    String fieldName;
    try {
      fieldName = "fixedSizeArray";
      encoder0.encodeUint8Array(fixedSizeArray, 8, bindings.kNothingNullable, 3);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructF("
           "fixedSizeArray: $fixedSizeArray" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["fixedSizeArray"] = fixedSizeArray;
    return map;
  }
}


class StructG extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0),
    const bindings.StructDataHeader(24, 1),
    const bindings.StructDataHeader(32, 3)
  ];
  int i = 0;
  bool b = false;
  StructA structA = null;
  String str = null;

  StructG() : super(kVersions.last.size);

  StructG.init(
    int this.i, 
    bool this.b, 
    StructA this.structA, 
    String this.str
  ) : super(kVersions.last.size);

  static StructG deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructG decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructG result = new StructG();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.i = decoder0.decodeInt32(8);
    }
    if (mainDataHeader.version >= 3) {
      
      result.b = decoder0.decodeBool(12, 0);
    }
    if (mainDataHeader.version >= 1) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.structA = StructA.decode(decoder1);
    }
    if (mainDataHeader.version >= 3) {
      
      result.str = decoder0.decodeString(24, true);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructG";
    String fieldName;
    try {
      fieldName = "i";
      encoder0.encodeInt32(i, 8);
      fieldName = "b";
      encoder0.encodeBool(b, 12, 0);
      fieldName = "structA";
      encoder0.encodeStruct(structA, 16, true);
      fieldName = "str";
      encoder0.encodeString(str, 24, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructG("
           "i: $i" ", "
           "b: $b" ", "
           "structA: $structA" ", "
           "str: $str" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["i"] = i;
    map["b"] = b;
    map["structA"] = structA;
    map["str"] = str;
    return map;
  }
}


class StructH extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(48, 0)
  ];
  bool a = false;
  int b = 0;
  UnionA c = null;
  List<UnionA> d = null;
  Map<int, UnionA> e = null;

  StructH() : super(kVersions.last.size);

  StructH.init(
    bool this.a, 
    int this.b, 
    UnionA this.c, 
    List<UnionA> this.d, 
    Map<int, UnionA> this.e
  ) : super(kVersions.last.size);

  static StructH deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructH decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructH result = new StructH();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.a = decoder0.decodeBool(8, 0);
    }
    if (mainDataHeader.version >= 0) {
      
      result.b = decoder0.decodeUint8(9);
    }
    if (mainDataHeader.version >= 0) {
      
        result.c = UnionA.decode(decoder0, 16);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(32, true);
      if (decoder1 == null) {
        result.d = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForUnionArray(bindings.kUnspecifiedArrayLength);
        result.d = new List<UnionA>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
            result.d[i1] = UnionA.decode(decoder1, bindings.ArrayDataHeader.kHeaderSize + bindings.kUnionSize * i1);
            if (result.d[i1] == null) {
              throw new bindings.MojoCodecError(
                'Trying to decode null union for non-nullable UnionA.');
            }
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(40, true);
      if (decoder1 == null) {
        result.e = null;
      } else {
        decoder1.decodeDataHeaderForMap();
        List<int> keys0;
        List<UnionA> values0;
        {
          
          keys0 = decoder1.decodeUint8Array(bindings.ArrayDataHeader.kHeaderSize, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        }
        {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize, false);
          {
            var si2 = decoder2.decodeDataHeaderForUnionArray(keys0.length);
            values0 = new List<UnionA>(si2.numElements);
            for (int i2 = 0; i2 < si2.numElements; ++i2) {
              
                values0[i2] = UnionA.decode(decoder2, bindings.ArrayDataHeader.kHeaderSize + bindings.kUnionSize * i2);
                if (values0[i2] == null) {
                  throw new bindings.MojoCodecError(
                    'Trying to decode null union for non-nullable UnionA.');
                }
            }
          }
        }
        result.e = new Map<int, UnionA>.fromIterables(
            keys0, values0);
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructH";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeBool(a, 8, 0);
      fieldName = "b";
      encoder0.encodeUint8(b, 9);
      fieldName = "c";
      encoder0.encodeUnion(c, 16, true);
      fieldName = "d";
      if (d == null) {
        encoder0.encodeNullPointer(32, true);
      } else {
        var encoder1 = encoder0.encodeUnionArray(d.length, 32, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < d.length; ++i0) {
          encoder1.encodeUnion(d[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kUnionSize * i0, false);
        }
      }
      fieldName = "e";
      if (e == null) {
        encoder0.encodeNullPointer(40, true);
      } else {
        var encoder1 = encoder0.encoderForMap(40);
        var keys0 = e.keys.toList();
        var values0 = e.values.toList();
        encoder1.encodeUint8Array(keys0, bindings.ArrayDataHeader.kHeaderSize, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        
        {
          var encoder2 = encoder1.encodeUnionArray(values0.length, bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize, bindings.kUnspecifiedArrayLength);
          for (int i1 = 0; i1 < values0.length; ++i1) {
            encoder2.encodeUnion(values0[i1], bindings.ArrayDataHeader.kHeaderSize + bindings.kUnionSize * i1, false);
          }
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructH("
           "a: $a" ", "
           "b: $b" ", "
           "c: $c" ", "
           "d: $d" ", "
           "e: $e" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    map["b"] = b;
    map["c"] = c;
    map["d"] = d;
    map["e"] = e;
    return map;
  }
}


class BasicStruct extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int a = 0;

  BasicStruct() : super(kVersions.last.size);

  BasicStruct.init(
    int this.a
  ) : super(kVersions.last.size);

  static BasicStruct deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static BasicStruct decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    BasicStruct result = new BasicStruct();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.a = decoder0.decodeInt32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "BasicStruct";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeInt32(a, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "BasicStruct("
           "a: $a" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    return map;
  }
}


class StructWithEnumEnumWithin extends bindings.MojoEnum {
  static const StructWithEnumEnumWithin a = const StructWithEnumEnumWithin._(0);
  static const StructWithEnumEnumWithin b = const StructWithEnumEnumWithin._(1);
  static const StructWithEnumEnumWithin c = const StructWithEnumEnumWithin._(2);
  static const StructWithEnumEnumWithin d = const StructWithEnumEnumWithin._(3);

  const StructWithEnumEnumWithin._(int v) : super(v);

  static const Map<String, StructWithEnumEnumWithin> valuesMap = const {
    "a": a,
    "b": b,
    "c": c,
    "d": d,
  };
  static const List<StructWithEnumEnumWithin> values = const [
    a,
    b,
    c,
    d,
  ];

  static StructWithEnumEnumWithin valueOf(String name) => valuesMap[name];

  factory StructWithEnumEnumWithin(int v) {
    switch (v) {
      case 0:
        return StructWithEnumEnumWithin.a;
      case 1:
        return StructWithEnumEnumWithin.b;
      case 2:
        return StructWithEnumEnumWithin.c;
      case 3:
        return StructWithEnumEnumWithin.d;
      default:
        return null;
    }
  }

  static StructWithEnumEnumWithin decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    StructWithEnumEnumWithin result = new StructWithEnumEnumWithin(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum StructWithEnumEnumWithin.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case a:
        return 'StructWithEnumEnumWithin.a';
      case b:
        return 'StructWithEnumEnumWithin.b';
      case c:
        return 'StructWithEnumEnumWithin.c';
      case d:
        return 'StructWithEnumEnumWithin.d';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class StructWithEnum extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  StructWithEnum() : super(kVersions.last.size);

  StructWithEnum.init(
  ) : super(kVersions.last.size);

  static StructWithEnum deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithEnum decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithEnum result = new StructWithEnum();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithEnum";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithEnum("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _BoundsCheckTestInterfaceMethod0Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int param0 = 0;

  _BoundsCheckTestInterfaceMethod0Params() : super(kVersions.last.size);

  _BoundsCheckTestInterfaceMethod0Params.init(
    int this.param0
  ) : super(kVersions.last.size);

  static _BoundsCheckTestInterfaceMethod0Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _BoundsCheckTestInterfaceMethod0Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _BoundsCheckTestInterfaceMethod0Params result = new _BoundsCheckTestInterfaceMethod0Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.param0 = decoder0.decodeUint8(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_BoundsCheckTestInterfaceMethod0Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeUint8(param0, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_BoundsCheckTestInterfaceMethod0Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class BoundsCheckTestInterfaceMethod0ResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int param0 = 0;

  BoundsCheckTestInterfaceMethod0ResponseParams() : super(kVersions.last.size);

  BoundsCheckTestInterfaceMethod0ResponseParams.init(
    int this.param0
  ) : super(kVersions.last.size);

  static BoundsCheckTestInterfaceMethod0ResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static BoundsCheckTestInterfaceMethod0ResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    BoundsCheckTestInterfaceMethod0ResponseParams result = new BoundsCheckTestInterfaceMethod0ResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.param0 = decoder0.decodeUint8(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "BoundsCheckTestInterfaceMethod0ResponseParams";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeUint8(param0, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "BoundsCheckTestInterfaceMethod0ResponseParams("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class _BoundsCheckTestInterfaceMethod1Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int param0 = 0;

  _BoundsCheckTestInterfaceMethod1Params() : super(kVersions.last.size);

  _BoundsCheckTestInterfaceMethod1Params.init(
    int this.param0
  ) : super(kVersions.last.size);

  static _BoundsCheckTestInterfaceMethod1Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _BoundsCheckTestInterfaceMethod1Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _BoundsCheckTestInterfaceMethod1Params result = new _BoundsCheckTestInterfaceMethod1Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.param0 = decoder0.decodeUint8(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_BoundsCheckTestInterfaceMethod1Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeUint8(param0, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_BoundsCheckTestInterfaceMethod1Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class _ConformanceTestInterfaceMethod0Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  double param0 = 0.0;

  _ConformanceTestInterfaceMethod0Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod0Params.init(
    double this.param0
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod0Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod0Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod0Params result = new _ConformanceTestInterfaceMethod0Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.param0 = decoder0.decodeFloat(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod0Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeFloat(param0, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod0Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class _ConformanceTestInterfaceMethod1Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  StructA param0 = null;

  _ConformanceTestInterfaceMethod1Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod1Params.init(
    StructA this.param0
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod1Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod1Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod1Params result = new _ConformanceTestInterfaceMethod1Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.param0 = StructA.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod1Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeStruct(param0, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod1Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class _ConformanceTestInterfaceMethod2Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  StructB param0 = null;
  StructA param1 = null;

  _ConformanceTestInterfaceMethod2Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod2Params.init(
    StructB this.param0, 
    StructA this.param1
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod2Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod2Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod2Params result = new _ConformanceTestInterfaceMethod2Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.param0 = StructB.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, false);
      result.param1 = StructA.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod2Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeStruct(param0, 8, false);
      fieldName = "param1";
      encoder0.encodeStruct(param1, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod2Params("
           "param0: $param0" ", "
           "param1: $param1" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    map["param1"] = param1;
    return map;
  }
}


class _ConformanceTestInterfaceMethod3Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<bool> param0 = null;

  _ConformanceTestInterfaceMethod3Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod3Params.init(
    List<bool> this.param0
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod3Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod3Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod3Params result = new _ConformanceTestInterfaceMethod3Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.param0 = decoder0.decodeBoolArray(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod3Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeBoolArray(param0, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod3Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class _ConformanceTestInterfaceMethod4Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  StructC param0 = null;
  List<int> param1 = null;

  _ConformanceTestInterfaceMethod4Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod4Params.init(
    StructC this.param0, 
    List<int> this.param1
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod4Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod4Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod4Params result = new _ConformanceTestInterfaceMethod4Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.param0 = StructC.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.param1 = decoder0.decodeUint8Array(16, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod4Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeStruct(param0, 8, false);
      fieldName = "param1";
      encoder0.encodeUint8Array(param1, 16, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod4Params("
           "param0: $param0" ", "
           "param1: $param1" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    map["param1"] = param1;
    return map;
  }
}


class _ConformanceTestInterfaceMethod5Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  StructE param0 = null;
  core.MojoDataPipeProducer param1 = null;

  _ConformanceTestInterfaceMethod5Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod5Params.init(
    StructE this.param0, 
    core.MojoDataPipeProducer this.param1
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod5Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod5Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod5Params result = new _ConformanceTestInterfaceMethod5Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.param0 = StructE.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.param1 = decoder0.decodeProducerHandle(16, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod5Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeStruct(param0, 8, false);
      fieldName = "param1";
      encoder0.encodeProducerHandle(param1, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod5Params("
           "param0: $param0" ", "
           "param1: $param1" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _ConformanceTestInterfaceMethod6Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<List<int>> param0 = null;

  _ConformanceTestInterfaceMethod6Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod6Params.init(
    List<List<int>> this.param0
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod6Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod6Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod6Params result = new _ConformanceTestInterfaceMethod6Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.param0 = new List<List<int>>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.param0[i1] = decoder1.decodeUint8Array(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod6Params";
    String fieldName;
    try {
      fieldName = "param0";
      if (param0 == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(param0.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < param0.length; ++i0) {
          encoder1.encodeUint8Array(param0[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod6Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class _ConformanceTestInterfaceMethod7Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  StructF param0 = null;
  List<List<int>> param1 = null;

  _ConformanceTestInterfaceMethod7Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod7Params.init(
    StructF this.param0, 
    List<List<int>> this.param1
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod7Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod7Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod7Params result = new _ConformanceTestInterfaceMethod7Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.param0 = StructF.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(2);
        result.param1 = new List<List<int>>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.param1[i1] = decoder1.decodeUint8Array(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, bindings.kArrayNullable, 3);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod7Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeStruct(param0, 8, false);
      fieldName = "param1";
      if (param1 == null) {
        encoder0.encodeNullPointer(16, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(param1.length, 16, 2);
        for (int i0 = 0; i0 < param1.length; ++i0) {
          encoder1.encodeUint8Array(param1[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, bindings.kArrayNullable, 3);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod7Params("
           "param0: $param0" ", "
           "param1: $param1" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    map["param1"] = param1;
    return map;
  }
}


class _ConformanceTestInterfaceMethod8Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<List<String>> param0 = null;

  _ConformanceTestInterfaceMethod8Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod8Params.init(
    List<List<String>> this.param0
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod8Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod8Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod8Params result = new _ConformanceTestInterfaceMethod8Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.param0 = new List<List<String>>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, true);
          if (decoder2 == null) {
            result.param0[i1] = null;
          } else {
            var si2 = decoder2.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
            result.param0[i1] = new List<String>(si2.numElements);
            for (int i2 = 0; i2 < si2.numElements; ++i2) {
              
              result.param0[i1][i2] = decoder2.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i2, false);
            }
          }
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod8Params";
    String fieldName;
    try {
      fieldName = "param0";
      if (param0 == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(param0.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < param0.length; ++i0) {
          if (param0[i0] == null) {
            encoder1.encodeNullPointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, true);
          } else {
            var encoder2 = encoder1.encodePointerArray(param0[i0].length, bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, bindings.kUnspecifiedArrayLength);
            for (int i1 = 0; i1 < param0[i0].length; ++i1) {
              encoder2.encodeString(param0[i0][i1], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
            }
          }
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod8Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class _ConformanceTestInterfaceMethod9Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<List<core.MojoHandle>> param0 = null;

  _ConformanceTestInterfaceMethod9Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod9Params.init(
    List<List<core.MojoHandle>> this.param0
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod9Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod9Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod9Params result = new _ConformanceTestInterfaceMethod9Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      if (decoder1 == null) {
        result.param0 = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.param0 = new List<List<core.MojoHandle>>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.param0[i1] = decoder1.decodeHandleArray(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod9Params";
    String fieldName;
    try {
      fieldName = "param0";
      if (param0 == null) {
        encoder0.encodeNullPointer(8, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(param0.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < param0.length; ++i0) {
          encoder1.encodeHandleArray(param0[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, bindings.kElementNullable, bindings.kUnspecifiedArrayLength);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod9Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _ConformanceTestInterfaceMethod10Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Map<String, int> param0 = null;

  _ConformanceTestInterfaceMethod10Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod10Params.init(
    Map<String, int> this.param0
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod10Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod10Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod10Params result = new _ConformanceTestInterfaceMethod10Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        decoder1.decodeDataHeaderForMap();
        List<String> keys0;
        List<int> values0;
        {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize, false);
          {
            var si2 = decoder2.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
            keys0 = new List<String>(si2.numElements);
            for (int i2 = 0; i2 < si2.numElements; ++i2) {
              
              keys0[i2] = decoder2.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i2, false);
            }
          }
        }
        {
          
          values0 = decoder1.decodeUint8Array(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize, bindings.kNothingNullable, keys0.length);
        }
        result.param0 = new Map<String, int>.fromIterables(
            keys0, values0);
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod10Params";
    String fieldName;
    try {
      fieldName = "param0";
      if (param0 == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encoderForMap(8);
        var keys0 = param0.keys.toList();
        var values0 = param0.values.toList();
        
        {
          var encoder2 = encoder1.encodePointerArray(keys0.length, bindings.ArrayDataHeader.kHeaderSize, bindings.kUnspecifiedArrayLength);
          for (int i1 = 0; i1 < keys0.length; ++i1) {
            encoder2.encodeString(keys0[i1], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          }
        }
        encoder1.encodeUint8Array(values0, bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod10Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class _ConformanceTestInterfaceMethod11Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  StructG param0 = null;

  _ConformanceTestInterfaceMethod11Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod11Params.init(
    StructG this.param0
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod11Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod11Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod11Params result = new _ConformanceTestInterfaceMethod11Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.param0 = StructG.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod11Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeStruct(param0, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod11Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class _ConformanceTestInterfaceMethod12Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  double param0 = 0.0;

  _ConformanceTestInterfaceMethod12Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod12Params.init(
    double this.param0
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod12Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod12Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod12Params result = new _ConformanceTestInterfaceMethod12Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.param0 = decoder0.decodeFloat(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod12Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeFloat(param0, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod12Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class ConformanceTestInterfaceMethod12ResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  double param0 = 0.0;

  ConformanceTestInterfaceMethod12ResponseParams() : super(kVersions.last.size);

  ConformanceTestInterfaceMethod12ResponseParams.init(
    double this.param0
  ) : super(kVersions.last.size);

  static ConformanceTestInterfaceMethod12ResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ConformanceTestInterfaceMethod12ResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ConformanceTestInterfaceMethod12ResponseParams result = new ConformanceTestInterfaceMethod12ResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.param0 = decoder0.decodeFloat(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ConformanceTestInterfaceMethod12ResponseParams";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeFloat(param0, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ConformanceTestInterfaceMethod12ResponseParams("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class _ConformanceTestInterfaceMethod13Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  InterfaceAInterface param0 = null;
  int param1 = 0;
  InterfaceAInterface param2 = null;

  _ConformanceTestInterfaceMethod13Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod13Params.init(
    InterfaceAInterface this.param0, 
    int this.param1, 
    InterfaceAInterface this.param2
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod13Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod13Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod13Params result = new _ConformanceTestInterfaceMethod13Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.param0 = decoder0.decodeServiceInterface(8, true, InterfaceAProxy.newFromEndpoint);
    }
    if (mainDataHeader.version >= 0) {
      
      result.param1 = decoder0.decodeUint32(16);
    }
    if (mainDataHeader.version >= 0) {
      
      result.param2 = decoder0.decodeServiceInterface(20, true, InterfaceAProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod13Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeInterface(param0, 8, true);
      fieldName = "param1";
      encoder0.encodeUint32(param1, 16);
      fieldName = "param2";
      encoder0.encodeInterface(param2, 20, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod13Params("
           "param0: $param0" ", "
           "param1: $param1" ", "
           "param2: $param2" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _ConformanceTestInterfaceMethod14Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  UnionA param0 = null;

  _ConformanceTestInterfaceMethod14Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod14Params.init(
    UnionA this.param0
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod14Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod14Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod14Params result = new _ConformanceTestInterfaceMethod14Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.param0 = UnionA.decode(decoder0, 8);
        if (result.param0 == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable UnionA.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod14Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeUnion(param0, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod14Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class _ConformanceTestInterfaceMethod15Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  StructH param0 = null;

  _ConformanceTestInterfaceMethod15Params() : super(kVersions.last.size);

  _ConformanceTestInterfaceMethod15Params.init(
    StructH this.param0
  ) : super(kVersions.last.size);

  static _ConformanceTestInterfaceMethod15Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ConformanceTestInterfaceMethod15Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ConformanceTestInterfaceMethod15Params result = new _ConformanceTestInterfaceMethod15Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.param0 = StructH.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ConformanceTestInterfaceMethod15Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeStruct(param0, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ConformanceTestInterfaceMethod15Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class _IntegrationTestInterfaceMethod0Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  BasicStruct param0 = null;

  _IntegrationTestInterfaceMethod0Params() : super(kVersions.last.size);

  _IntegrationTestInterfaceMethod0Params.init(
    BasicStruct this.param0
  ) : super(kVersions.last.size);

  static _IntegrationTestInterfaceMethod0Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _IntegrationTestInterfaceMethod0Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _IntegrationTestInterfaceMethod0Params result = new _IntegrationTestInterfaceMethod0Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.param0 = BasicStruct.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_IntegrationTestInterfaceMethod0Params";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeStruct(param0, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_IntegrationTestInterfaceMethod0Params("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}


class IntegrationTestInterfaceMethod0ResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<int> param0 = null;

  IntegrationTestInterfaceMethod0ResponseParams() : super(kVersions.last.size);

  IntegrationTestInterfaceMethod0ResponseParams.init(
    List<int> this.param0
  ) : super(kVersions.last.size);

  static IntegrationTestInterfaceMethod0ResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static IntegrationTestInterfaceMethod0ResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    IntegrationTestInterfaceMethod0ResponseParams result = new IntegrationTestInterfaceMethod0ResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.param0 = decoder0.decodeUint8Array(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "IntegrationTestInterfaceMethod0ResponseParams";
    String fieldName;
    try {
      fieldName = "param0";
      encoder0.encodeUint8Array(param0, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "IntegrationTestInterfaceMethod0ResponseParams("
           "param0: $param0" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["param0"] = param0;
    return map;
  }
}



enum UnionATag {
  a,
  b,
  c,
  d,
  e,
  f,
  g,
  h,
  i,
  j,
  unknown
}

class UnionA extends bindings.Union {
  static final _tagToInt = const {
    UnionATag.a: 0,
    UnionATag.b: 1,
    UnionATag.c: 2,
    UnionATag.d: 3,
    UnionATag.e: 4,
    UnionATag.f: 5,
    UnionATag.g: 6,
    UnionATag.h: 7,
    UnionATag.i: 8,
    UnionATag.j: 9,
  };

  static final _intToTag = const {
    0: UnionATag.a,
    1: UnionATag.b,
    2: UnionATag.c,
    3: UnionATag.d,
    4: UnionATag.e,
    5: UnionATag.f,
    6: UnionATag.g,
    7: UnionATag.h,
    8: UnionATag.i,
    9: UnionATag.j,
  };

  var _data;
  UnionATag _tag = UnionATag.unknown;

  UnionATag get tag => _tag;
  int get a {
    if (_tag != UnionATag.a) {
      throw new bindings.UnsetUnionTagError(_tag, UnionATag.a);
    }
    return _data;
  }

  set a(int value) {
    _tag = UnionATag.a;
    _data = value;
  }
  int get b {
    if (_tag != UnionATag.b) {
      throw new bindings.UnsetUnionTagError(_tag, UnionATag.b);
    }
    return _data;
  }

  set b(int value) {
    _tag = UnionATag.b;
    _data = value;
  }
  StructA get c {
    if (_tag != UnionATag.c) {
      throw new bindings.UnsetUnionTagError(_tag, UnionATag.c);
    }
    return _data;
  }

  set c(StructA value) {
    _tag = UnionATag.c;
    _data = value;
  }
  List<int> get d {
    if (_tag != UnionATag.d) {
      throw new bindings.UnsetUnionTagError(_tag, UnionATag.d);
    }
    return _data;
  }

  set d(List<int> value) {
    _tag = UnionATag.d;
    _data = value;
  }
  Map<String, int> get e {
    if (_tag != UnionATag.e) {
      throw new bindings.UnsetUnionTagError(_tag, UnionATag.e);
    }
    return _data;
  }

  set e(Map<String, int> value) {
    _tag = UnionATag.e;
    _data = value;
  }
  UnionB get f {
    if (_tag != UnionATag.f) {
      throw new bindings.UnsetUnionTagError(_tag, UnionATag.f);
    }
    return _data;
  }

  set f(UnionB value) {
    _tag = UnionATag.f;
    _data = value;
  }
  StructA get g {
    if (_tag != UnionATag.g) {
      throw new bindings.UnsetUnionTagError(_tag, UnionATag.g);
    }
    return _data;
  }

  set g(StructA value) {
    _tag = UnionATag.g;
    _data = value;
  }
  List<int> get h {
    if (_tag != UnionATag.h) {
      throw new bindings.UnsetUnionTagError(_tag, UnionATag.h);
    }
    return _data;
  }

  set h(List<int> value) {
    _tag = UnionATag.h;
    _data = value;
  }
  Map<String, int> get i {
    if (_tag != UnionATag.i) {
      throw new bindings.UnsetUnionTagError(_tag, UnionATag.i);
    }
    return _data;
  }

  set i(Map<String, int> value) {
    _tag = UnionATag.i;
    _data = value;
  }
  UnionB get j {
    if (_tag != UnionATag.j) {
      throw new bindings.UnsetUnionTagError(_tag, UnionATag.j);
    }
    return _data;
  }

  set j(UnionB value) {
    _tag = UnionATag.j;
    _data = value;
  }

  static UnionA decode(bindings.Decoder decoder0, int offset) {
    int size = decoder0.decodeUint32(offset);
    if (size == 0) {
      return null;
    }
    UnionA result = new UnionA();

    
    UnionATag tag = _intToTag[decoder0.decodeUint32(offset + 4)];
    switch (tag) {
      case UnionATag.a:
        
        result.a = decoder0.decodeUint16(offset + 8);
        break;
      case UnionATag.b:
        
        result.b = decoder0.decodeUint32(offset + 8);
        break;
      case UnionATag.c:
        
        var decoder1 = decoder0.decodePointer(offset + 8, true);
        result.c = StructA.decode(decoder1);
        break;
      case UnionATag.d:
        
        result.d = decoder0.decodeUint8Array(offset + 8, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
        break;
      case UnionATag.e:
        
        var decoder1 = decoder0.decodePointer(offset + 8, true);
        if (decoder1 == null) {
          result.e = null;
        } else {
          decoder1.decodeDataHeaderForMap();
          List<String> keys0;
          List<int> values0;
          {
            
            var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize, false);
            {
              var si2 = decoder2.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
              keys0 = new List<String>(si2.numElements);
              for (int i2 = 0; i2 < si2.numElements; ++i2) {
                
                keys0[i2] = decoder2.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i2, false);
              }
            }
          }
          {
            
            values0 = decoder1.decodeUint8Array(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize, bindings.kNothingNullable, keys0.length);
          }
          result.e = new Map<String, int>.fromIterables(
              keys0, values0);
        }
        break;
      case UnionATag.f:
        var decoder1 = decoder0.decodePointer(offset + 8, true);
        result.f = UnionB.decode(decoder1, 0);
        break;
      case UnionATag.g:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.g = StructA.decode(decoder1);
        break;
      case UnionATag.h:
        
        result.h = decoder0.decodeUint8Array(offset + 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        break;
      case UnionATag.i:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        {
          decoder1.decodeDataHeaderForMap();
          List<String> keys0;
          List<int> values0;
          {
            
            var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize, false);
            {
              var si2 = decoder2.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
              keys0 = new List<String>(si2.numElements);
              for (int i2 = 0; i2 < si2.numElements; ++i2) {
                
                keys0[i2] = decoder2.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i2, false);
              }
            }
          }
          {
            
            values0 = decoder1.decodeUint8Array(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize, bindings.kNothingNullable, keys0.length);
          }
          result.i = new Map<String, int>.fromIterables(
              keys0, values0);
        }
        break;
      case UnionATag.j:
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.j = UnionB.decode(decoder1, 0);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $tag");
    }

    return result;
  }

  void encode(bindings.Encoder encoder0, int offset) {
    
    encoder0.encodeUint32(16, offset);
    encoder0.encodeUint32(_tagToInt[_tag], offset + 4);
    switch (_tag) {
      case UnionATag.a:
        encoder0.encodeUint16(a, offset + 8);
        break;
      case UnionATag.b:
        encoder0.encodeUint32(b, offset + 8);
        break;
      case UnionATag.c:
        encoder0.encodeStruct(c, offset + 8, true);
        break;
      case UnionATag.d:
        encoder0.encodeUint8Array(d, offset + 8, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
        break;
      case UnionATag.e:
        if (e == null) {
          encoder0.encodeNullPointer(offset + 8, true);
        } else {
          var encoder1 = encoder0.encoderForMap(offset + 8);
          var keys0 = e.keys.toList();
          var values0 = e.values.toList();
          
          {
            var encoder2 = encoder1.encodePointerArray(keys0.length, bindings.ArrayDataHeader.kHeaderSize, bindings.kUnspecifiedArrayLength);
            for (int i1 = 0; i1 < keys0.length; ++i1) {
              encoder2.encodeString(keys0[i1], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
            }
          }
          encoder1.encodeUint8Array(values0, bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        }
        break;
      case UnionATag.f:
        encoder0.encodeNestedUnion(f, offset + 8, true);
        break;
      case UnionATag.g:
        encoder0.encodeStruct(g, offset + 8, false);
        break;
      case UnionATag.h:
        encoder0.encodeUint8Array(h, offset + 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        break;
      case UnionATag.i:
        if (i == null) {
          encoder0.encodeNullPointer(offset + 8, false);
        } else {
          var encoder1 = encoder0.encoderForMap(offset + 8);
          var keys0 = i.keys.toList();
          var values0 = i.values.toList();
          
          {
            var encoder2 = encoder1.encodePointerArray(keys0.length, bindings.ArrayDataHeader.kHeaderSize, bindings.kUnspecifiedArrayLength);
            for (int i1 = 0; i1 < keys0.length; ++i1) {
              encoder2.encodeString(keys0[i1], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
            }
          }
          encoder1.encodeUint8Array(values0, bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        }
        break;
      case UnionATag.j:
        encoder0.encodeNestedUnion(j, offset + 8, false);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $_tag");
    }
  }

  String toString() {
    String result = "UnionA(";
    switch (_tag) {
      case UnionATag.a:
        result += "a";
        break;
      case UnionATag.b:
        result += "b";
        break;
      case UnionATag.c:
        result += "c";
        break;
      case UnionATag.d:
        result += "d";
        break;
      case UnionATag.e:
        result += "e";
        break;
      case UnionATag.f:
        result += "f";
        break;
      case UnionATag.g:
        result += "g";
        break;
      case UnionATag.h:
        result += "h";
        break;
      case UnionATag.i:
        result += "i";
        break;
      case UnionATag.j:
        result += "j";
        break;
      default:
        result += "unknown";
    }
    result += ": $_data)";
    return result;
  }
}


enum UnionBTag {
  a,
  b,
  c,
  d,
  unknown
}

class UnionB extends bindings.Union {
  static final _tagToInt = const {
    UnionBTag.a: 0,
    UnionBTag.b: 1,
    UnionBTag.c: 2,
    UnionBTag.d: 3,
  };

  static final _intToTag = const {
    0: UnionBTag.a,
    1: UnionBTag.b,
    2: UnionBTag.c,
    3: UnionBTag.d,
  };

  var _data;
  UnionBTag _tag = UnionBTag.unknown;

  UnionBTag get tag => _tag;
  int get a {
    if (_tag != UnionBTag.a) {
      throw new bindings.UnsetUnionTagError(_tag, UnionBTag.a);
    }
    return _data;
  }

  set a(int value) {
    _tag = UnionBTag.a;
    _data = value;
  }
  int get b {
    if (_tag != UnionBTag.b) {
      throw new bindings.UnsetUnionTagError(_tag, UnionBTag.b);
    }
    return _data;
  }

  set b(int value) {
    _tag = UnionBTag.b;
    _data = value;
  }
  int get c {
    if (_tag != UnionBTag.c) {
      throw new bindings.UnsetUnionTagError(_tag, UnionBTag.c);
    }
    return _data;
  }

  set c(int value) {
    _tag = UnionBTag.c;
    _data = value;
  }
  int get d {
    if (_tag != UnionBTag.d) {
      throw new bindings.UnsetUnionTagError(_tag, UnionBTag.d);
    }
    return _data;
  }

  set d(int value) {
    _tag = UnionBTag.d;
    _data = value;
  }

  static UnionB decode(bindings.Decoder decoder0, int offset) {
    int size = decoder0.decodeUint32(offset);
    if (size == 0) {
      return null;
    }
    UnionB result = new UnionB();

    
    UnionBTag tag = _intToTag[decoder0.decodeUint32(offset + 4)];
    switch (tag) {
      case UnionBTag.a:
        
        result.a = decoder0.decodeUint16(offset + 8);
        break;
      case UnionBTag.b:
        
        result.b = decoder0.decodeUint32(offset + 8);
        break;
      case UnionBTag.c:
        
        result.c = decoder0.decodeUint64(offset + 8);
        break;
      case UnionBTag.d:
        
        result.d = decoder0.decodeUint32(offset + 8);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $tag");
    }

    return result;
  }

  void encode(bindings.Encoder encoder0, int offset) {
    
    encoder0.encodeUint32(16, offset);
    encoder0.encodeUint32(_tagToInt[_tag], offset + 4);
    switch (_tag) {
      case UnionBTag.a:
        encoder0.encodeUint16(a, offset + 8);
        break;
      case UnionBTag.b:
        encoder0.encodeUint32(b, offset + 8);
        break;
      case UnionBTag.c:
        encoder0.encodeUint64(c, offset + 8);
        break;
      case UnionBTag.d:
        encoder0.encodeUint32(d, offset + 8);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $_tag");
    }
  }

  String toString() {
    String result = "UnionB(";
    switch (_tag) {
      case UnionBTag.a:
        result += "a";
        break;
      case UnionBTag.b:
        result += "b";
        break;
      case UnionBTag.c:
        result += "c";
        break;
      case UnionBTag.d:
        result += "d";
        break;
      default:
        result += "unknown";
    }
    result += ": $_data)";
    return result;
  }
}

class _InterfaceAServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class InterfaceA {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _InterfaceAServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static InterfaceAProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    InterfaceAProxy p = new InterfaceAProxy.unbound();
    String name = serviceName ?? InterfaceA.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
}

abstract class InterfaceAInterface
    implements bindings.MojoInterface<InterfaceA>,
               InterfaceA {
  factory InterfaceAInterface([InterfaceA impl]) =>
      new InterfaceAStub.unbound(impl);

  factory InterfaceAInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [InterfaceA impl]) =>
      new InterfaceAStub.fromEndpoint(endpoint, impl);

  factory InterfaceAInterface.fromMock(
      InterfaceA mock) =>
      new InterfaceAProxy.fromMock(mock);
}

abstract class InterfaceAInterfaceRequest
    implements bindings.MojoInterface<InterfaceA>,
               InterfaceA {
  factory InterfaceAInterfaceRequest() =>
      new InterfaceAProxy.unbound();
}

class _InterfaceAProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<InterfaceA> {
  InterfaceA impl;

  _InterfaceAProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _InterfaceAProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _InterfaceAProxyControl.unbound() : super.unbound();

  String get serviceName => InterfaceA.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_InterfaceAProxyControl($superString)";
  }
}

class InterfaceAProxy
    extends bindings.Proxy<InterfaceA>
    implements InterfaceA,
               InterfaceAInterface,
               InterfaceAInterfaceRequest {
  InterfaceAProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _InterfaceAProxyControl.fromEndpoint(endpoint));

  InterfaceAProxy.fromHandle(core.MojoHandle handle)
      : super(new _InterfaceAProxyControl.fromHandle(handle));

  InterfaceAProxy.unbound()
      : super(new _InterfaceAProxyControl.unbound());

  factory InterfaceAProxy.fromMock(InterfaceA mock) {
    InterfaceAProxy newMockedProxy =
        new InterfaceAProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static InterfaceAProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For InterfaceAProxy"));
    return new InterfaceAProxy.fromEndpoint(endpoint);
  }


}

class _InterfaceAStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<InterfaceA> {
  InterfaceA _impl;

  _InterfaceAStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [InterfaceA impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _InterfaceAStubControl.fromHandle(
      core.MojoHandle handle, [InterfaceA impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _InterfaceAStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => InterfaceA.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  InterfaceA get impl => _impl;
  set impl(InterfaceA d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_InterfaceAStubControl($superString)";
  }

  int get version => 0;
}

class InterfaceAStub
    extends bindings.Stub<InterfaceA>
    implements InterfaceA,
               InterfaceAInterface,
               InterfaceAInterfaceRequest {
  InterfaceAStub.unbound([InterfaceA impl])
      : super(new _InterfaceAStubControl.unbound(impl));

  InterfaceAStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [InterfaceA impl])
      : super(new _InterfaceAStubControl.fromEndpoint(endpoint, impl));

  InterfaceAStub.fromHandle(
      core.MojoHandle handle, [InterfaceA impl])
      : super(new _InterfaceAStubControl.fromHandle(handle, impl));

  static InterfaceAStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For InterfaceAStub"));
    return new InterfaceAStub.fromEndpoint(endpoint);
  }


}

const int _boundsCheckTestInterfaceMethodMethod0Name = 0;
const int _boundsCheckTestInterfaceMethodMethod1Name = 1;

class _BoundsCheckTestInterfaceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder){
    var interfaceTypeKey = getRuntimeTypeInfo().services["this.is.the.service.name.for.BoundsCheckTestInterface"];
    var userDefinedType = getAllMojomTypeDefinitions()[interfaceTypeKey];
    responder(userDefinedType.interfaceType);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(getAllMojomTypeDefinitions()[typeKey]);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(getAllMojomTypeDefinitions());
  }
}

abstract class BoundsCheckTestInterface {
  static const String serviceName = "this.is.the.service.name.for.BoundsCheckTestInterface";

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _BoundsCheckTestInterfaceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static BoundsCheckTestInterfaceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    BoundsCheckTestInterfaceProxy p = new BoundsCheckTestInterfaceProxy.unbound();
    String name = serviceName ?? BoundsCheckTestInterface.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void method0(int param0,void callback(int param0));
  void method1(int param0);
}

abstract class BoundsCheckTestInterfaceInterface
    implements bindings.MojoInterface<BoundsCheckTestInterface>,
               BoundsCheckTestInterface {
  factory BoundsCheckTestInterfaceInterface([BoundsCheckTestInterface impl]) =>
      new BoundsCheckTestInterfaceStub.unbound(impl);

  factory BoundsCheckTestInterfaceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [BoundsCheckTestInterface impl]) =>
      new BoundsCheckTestInterfaceStub.fromEndpoint(endpoint, impl);

  factory BoundsCheckTestInterfaceInterface.fromMock(
      BoundsCheckTestInterface mock) =>
      new BoundsCheckTestInterfaceProxy.fromMock(mock);
}

abstract class BoundsCheckTestInterfaceInterfaceRequest
    implements bindings.MojoInterface<BoundsCheckTestInterface>,
               BoundsCheckTestInterface {
  factory BoundsCheckTestInterfaceInterfaceRequest() =>
      new BoundsCheckTestInterfaceProxy.unbound();
}

class _BoundsCheckTestInterfaceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<BoundsCheckTestInterface> {
  BoundsCheckTestInterface impl;

  _BoundsCheckTestInterfaceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _BoundsCheckTestInterfaceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _BoundsCheckTestInterfaceProxyControl.unbound() : super.unbound();

  String get serviceName => BoundsCheckTestInterface.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _boundsCheckTestInterfaceMethodMethod0Name:
        var r = BoundsCheckTestInterfaceMethod0ResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.param0 );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_BoundsCheckTestInterfaceProxyControl($superString)";
  }
}

class BoundsCheckTestInterfaceProxy
    extends bindings.Proxy<BoundsCheckTestInterface>
    implements BoundsCheckTestInterface,
               BoundsCheckTestInterfaceInterface,
               BoundsCheckTestInterfaceInterfaceRequest {
  BoundsCheckTestInterfaceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _BoundsCheckTestInterfaceProxyControl.fromEndpoint(endpoint));

  BoundsCheckTestInterfaceProxy.fromHandle(core.MojoHandle handle)
      : super(new _BoundsCheckTestInterfaceProxyControl.fromHandle(handle));

  BoundsCheckTestInterfaceProxy.unbound()
      : super(new _BoundsCheckTestInterfaceProxyControl.unbound());

  factory BoundsCheckTestInterfaceProxy.fromMock(BoundsCheckTestInterface mock) {
    BoundsCheckTestInterfaceProxy newMockedProxy =
        new BoundsCheckTestInterfaceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static BoundsCheckTestInterfaceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For BoundsCheckTestInterfaceProxy"));
    return new BoundsCheckTestInterfaceProxy.fromEndpoint(endpoint);
  }


  void method0(int param0,void callback(int param0)) {
    if (impl != null) {
      impl.method0(param0,callback);
      return;
    }
    var params = new _BoundsCheckTestInterfaceMethod0Params();
    params.param0 = param0;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((int param0) {
        z.bindCallback(() {
          callback(param0);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _boundsCheckTestInterfaceMethodMethod0Name,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void method1(int param0) {
    if (impl != null) {
      impl.method1(param0);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _BoundsCheckTestInterfaceMethod1Params();
    params.param0 = param0;
    ctrl.sendMessage(params,
        _boundsCheckTestInterfaceMethodMethod1Name);
  }
}

class _BoundsCheckTestInterfaceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<BoundsCheckTestInterface> {
  BoundsCheckTestInterface _impl;

  _BoundsCheckTestInterfaceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [BoundsCheckTestInterface impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _BoundsCheckTestInterfaceStubControl.fromHandle(
      core.MojoHandle handle, [BoundsCheckTestInterface impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _BoundsCheckTestInterfaceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => BoundsCheckTestInterface.serviceName;


  Function _boundsCheckTestInterfaceMethod0ResponseParamsResponder(
      int requestId) {
  return (int param0) {
      var result = new BoundsCheckTestInterfaceMethod0ResponseParams();
      result.param0 = param0;
      sendResponse(buildResponseWithId(
          result,
          _boundsCheckTestInterfaceMethodMethod0Name,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _boundsCheckTestInterfaceMethodMethod0Name:
        var params = _BoundsCheckTestInterfaceMethod0Params.deserialize(
            message.payload);
        _impl.method0(params.param0, _boundsCheckTestInterfaceMethod0ResponseParamsResponder(message.header.requestId));
        break;
      case _boundsCheckTestInterfaceMethodMethod1Name:
        var params = _BoundsCheckTestInterfaceMethod1Params.deserialize(
            message.payload);
        _impl.method1(params.param0);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  BoundsCheckTestInterface get impl => _impl;
  set impl(BoundsCheckTestInterface d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_BoundsCheckTestInterfaceStubControl($superString)";
  }

  int get version => 0;
}

class BoundsCheckTestInterfaceStub
    extends bindings.Stub<BoundsCheckTestInterface>
    implements BoundsCheckTestInterface,
               BoundsCheckTestInterfaceInterface,
               BoundsCheckTestInterfaceInterfaceRequest {
  BoundsCheckTestInterfaceStub.unbound([BoundsCheckTestInterface impl])
      : super(new _BoundsCheckTestInterfaceStubControl.unbound(impl));

  BoundsCheckTestInterfaceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [BoundsCheckTestInterface impl])
      : super(new _BoundsCheckTestInterfaceStubControl.fromEndpoint(endpoint, impl));

  BoundsCheckTestInterfaceStub.fromHandle(
      core.MojoHandle handle, [BoundsCheckTestInterface impl])
      : super(new _BoundsCheckTestInterfaceStubControl.fromHandle(handle, impl));

  static BoundsCheckTestInterfaceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For BoundsCheckTestInterfaceStub"));
    return new BoundsCheckTestInterfaceStub.fromEndpoint(endpoint);
  }


  void method0(int param0,void callback(int param0)) {
    return impl.method0(param0,callback);
  }
  void method1(int param0) {
    return impl.method1(param0);
  }
}

const int _conformanceTestInterfaceMethodMethod0Name = 0;
const int _conformanceTestInterfaceMethodMethod1Name = 1;
const int _conformanceTestInterfaceMethodMethod2Name = 2;
const int _conformanceTestInterfaceMethodMethod3Name = 3;
const int _conformanceTestInterfaceMethodMethod4Name = 4;
const int _conformanceTestInterfaceMethodMethod5Name = 5;
const int _conformanceTestInterfaceMethodMethod6Name = 6;
const int _conformanceTestInterfaceMethodMethod7Name = 7;
const int _conformanceTestInterfaceMethodMethod8Name = 8;
const int _conformanceTestInterfaceMethodMethod9Name = 9;
const int _conformanceTestInterfaceMethodMethod10Name = 10;
const int _conformanceTestInterfaceMethodMethod11Name = 11;
const int _conformanceTestInterfaceMethodMethod12Name = 12;
const int _conformanceTestInterfaceMethodMethod13Name = 13;
const int _conformanceTestInterfaceMethodMethod14Name = 14;
const int _conformanceTestInterfaceMethodMethod15Name = 15;

class _ConformanceTestInterfaceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class ConformanceTestInterface {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _ConformanceTestInterfaceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static ConformanceTestInterfaceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    ConformanceTestInterfaceProxy p = new ConformanceTestInterfaceProxy.unbound();
    String name = serviceName ?? ConformanceTestInterface.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void method0(double param0);
  void method1(StructA param0);
  void method2(StructB param0, StructA param1);
  void method3(List<bool> param0);
  void method4(StructC param0, List<int> param1);
  void method5(StructE param0, core.MojoDataPipeProducer param1);
  void method6(List<List<int>> param0);
  void method7(StructF param0, List<List<int>> param1);
  void method8(List<List<String>> param0);
  void method9(List<List<core.MojoHandle>> param0);
  void method10(Map<String, int> param0);
  void method11(StructG param0);
  void method12(double param0,void callback(double param0));
  void method13(InterfaceAInterface param0, int param1, InterfaceAInterface param2);
  void method14(UnionA param0);
  void method15(StructH param0);
}

abstract class ConformanceTestInterfaceInterface
    implements bindings.MojoInterface<ConformanceTestInterface>,
               ConformanceTestInterface {
  factory ConformanceTestInterfaceInterface([ConformanceTestInterface impl]) =>
      new ConformanceTestInterfaceStub.unbound(impl);

  factory ConformanceTestInterfaceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [ConformanceTestInterface impl]) =>
      new ConformanceTestInterfaceStub.fromEndpoint(endpoint, impl);

  factory ConformanceTestInterfaceInterface.fromMock(
      ConformanceTestInterface mock) =>
      new ConformanceTestInterfaceProxy.fromMock(mock);
}

abstract class ConformanceTestInterfaceInterfaceRequest
    implements bindings.MojoInterface<ConformanceTestInterface>,
               ConformanceTestInterface {
  factory ConformanceTestInterfaceInterfaceRequest() =>
      new ConformanceTestInterfaceProxy.unbound();
}

class _ConformanceTestInterfaceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<ConformanceTestInterface> {
  ConformanceTestInterface impl;

  _ConformanceTestInterfaceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _ConformanceTestInterfaceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _ConformanceTestInterfaceProxyControl.unbound() : super.unbound();

  String get serviceName => ConformanceTestInterface.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _conformanceTestInterfaceMethodMethod12Name:
        var r = ConformanceTestInterfaceMethod12ResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.param0 );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ConformanceTestInterfaceProxyControl($superString)";
  }
}

class ConformanceTestInterfaceProxy
    extends bindings.Proxy<ConformanceTestInterface>
    implements ConformanceTestInterface,
               ConformanceTestInterfaceInterface,
               ConformanceTestInterfaceInterfaceRequest {
  ConformanceTestInterfaceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _ConformanceTestInterfaceProxyControl.fromEndpoint(endpoint));

  ConformanceTestInterfaceProxy.fromHandle(core.MojoHandle handle)
      : super(new _ConformanceTestInterfaceProxyControl.fromHandle(handle));

  ConformanceTestInterfaceProxy.unbound()
      : super(new _ConformanceTestInterfaceProxyControl.unbound());

  factory ConformanceTestInterfaceProxy.fromMock(ConformanceTestInterface mock) {
    ConformanceTestInterfaceProxy newMockedProxy =
        new ConformanceTestInterfaceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static ConformanceTestInterfaceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ConformanceTestInterfaceProxy"));
    return new ConformanceTestInterfaceProxy.fromEndpoint(endpoint);
  }


  void method0(double param0) {
    if (impl != null) {
      impl.method0(param0);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod0Params();
    params.param0 = param0;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod0Name);
  }
  void method1(StructA param0) {
    if (impl != null) {
      impl.method1(param0);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod1Params();
    params.param0 = param0;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod1Name);
  }
  void method2(StructB param0, StructA param1) {
    if (impl != null) {
      impl.method2(param0, param1);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod2Params();
    params.param0 = param0;
    params.param1 = param1;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod2Name);
  }
  void method3(List<bool> param0) {
    if (impl != null) {
      impl.method3(param0);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod3Params();
    params.param0 = param0;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod3Name);
  }
  void method4(StructC param0, List<int> param1) {
    if (impl != null) {
      impl.method4(param0, param1);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod4Params();
    params.param0 = param0;
    params.param1 = param1;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod4Name);
  }
  void method5(StructE param0, core.MojoDataPipeProducer param1) {
    if (impl != null) {
      impl.method5(param0, param1);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod5Params();
    params.param0 = param0;
    params.param1 = param1;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod5Name);
  }
  void method6(List<List<int>> param0) {
    if (impl != null) {
      impl.method6(param0);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod6Params();
    params.param0 = param0;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod6Name);
  }
  void method7(StructF param0, List<List<int>> param1) {
    if (impl != null) {
      impl.method7(param0, param1);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod7Params();
    params.param0 = param0;
    params.param1 = param1;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod7Name);
  }
  void method8(List<List<String>> param0) {
    if (impl != null) {
      impl.method8(param0);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod8Params();
    params.param0 = param0;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod8Name);
  }
  void method9(List<List<core.MojoHandle>> param0) {
    if (impl != null) {
      impl.method9(param0);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod9Params();
    params.param0 = param0;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod9Name);
  }
  void method10(Map<String, int> param0) {
    if (impl != null) {
      impl.method10(param0);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod10Params();
    params.param0 = param0;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod10Name);
  }
  void method11(StructG param0) {
    if (impl != null) {
      impl.method11(param0);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod11Params();
    params.param0 = param0;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod11Name);
  }
  void method12(double param0,void callback(double param0)) {
    if (impl != null) {
      impl.method12(param0,callback);
      return;
    }
    var params = new _ConformanceTestInterfaceMethod12Params();
    params.param0 = param0;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((double param0) {
        z.bindCallback(() {
          callback(param0);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _conformanceTestInterfaceMethodMethod12Name,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void method13(InterfaceAInterface param0, int param1, InterfaceAInterface param2) {
    if (impl != null) {
      impl.method13(param0, param1, param2);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod13Params();
    params.param0 = param0;
    params.param1 = param1;
    params.param2 = param2;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod13Name);
  }
  void method14(UnionA param0) {
    if (impl != null) {
      impl.method14(param0);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod14Params();
    params.param0 = param0;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod14Name);
  }
  void method15(StructH param0) {
    if (impl != null) {
      impl.method15(param0);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ConformanceTestInterfaceMethod15Params();
    params.param0 = param0;
    ctrl.sendMessage(params,
        _conformanceTestInterfaceMethodMethod15Name);
  }
}

class _ConformanceTestInterfaceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<ConformanceTestInterface> {
  ConformanceTestInterface _impl;

  _ConformanceTestInterfaceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ConformanceTestInterface impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _ConformanceTestInterfaceStubControl.fromHandle(
      core.MojoHandle handle, [ConformanceTestInterface impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _ConformanceTestInterfaceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => ConformanceTestInterface.serviceName;


  Function _conformanceTestInterfaceMethod12ResponseParamsResponder(
      int requestId) {
  return (double param0) {
      var result = new ConformanceTestInterfaceMethod12ResponseParams();
      result.param0 = param0;
      sendResponse(buildResponseWithId(
          result,
          _conformanceTestInterfaceMethodMethod12Name,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _conformanceTestInterfaceMethodMethod0Name:
        var params = _ConformanceTestInterfaceMethod0Params.deserialize(
            message.payload);
        _impl.method0(params.param0);
        break;
      case _conformanceTestInterfaceMethodMethod1Name:
        var params = _ConformanceTestInterfaceMethod1Params.deserialize(
            message.payload);
        _impl.method1(params.param0);
        break;
      case _conformanceTestInterfaceMethodMethod2Name:
        var params = _ConformanceTestInterfaceMethod2Params.deserialize(
            message.payload);
        _impl.method2(params.param0, params.param1);
        break;
      case _conformanceTestInterfaceMethodMethod3Name:
        var params = _ConformanceTestInterfaceMethod3Params.deserialize(
            message.payload);
        _impl.method3(params.param0);
        break;
      case _conformanceTestInterfaceMethodMethod4Name:
        var params = _ConformanceTestInterfaceMethod4Params.deserialize(
            message.payload);
        _impl.method4(params.param0, params.param1);
        break;
      case _conformanceTestInterfaceMethodMethod5Name:
        var params = _ConformanceTestInterfaceMethod5Params.deserialize(
            message.payload);
        _impl.method5(params.param0, params.param1);
        break;
      case _conformanceTestInterfaceMethodMethod6Name:
        var params = _ConformanceTestInterfaceMethod6Params.deserialize(
            message.payload);
        _impl.method6(params.param0);
        break;
      case _conformanceTestInterfaceMethodMethod7Name:
        var params = _ConformanceTestInterfaceMethod7Params.deserialize(
            message.payload);
        _impl.method7(params.param0, params.param1);
        break;
      case _conformanceTestInterfaceMethodMethod8Name:
        var params = _ConformanceTestInterfaceMethod8Params.deserialize(
            message.payload);
        _impl.method8(params.param0);
        break;
      case _conformanceTestInterfaceMethodMethod9Name:
        var params = _ConformanceTestInterfaceMethod9Params.deserialize(
            message.payload);
        _impl.method9(params.param0);
        break;
      case _conformanceTestInterfaceMethodMethod10Name:
        var params = _ConformanceTestInterfaceMethod10Params.deserialize(
            message.payload);
        _impl.method10(params.param0);
        break;
      case _conformanceTestInterfaceMethodMethod11Name:
        var params = _ConformanceTestInterfaceMethod11Params.deserialize(
            message.payload);
        _impl.method11(params.param0);
        break;
      case _conformanceTestInterfaceMethodMethod12Name:
        var params = _ConformanceTestInterfaceMethod12Params.deserialize(
            message.payload);
        _impl.method12(params.param0, _conformanceTestInterfaceMethod12ResponseParamsResponder(message.header.requestId));
        break;
      case _conformanceTestInterfaceMethodMethod13Name:
        var params = _ConformanceTestInterfaceMethod13Params.deserialize(
            message.payload);
        _impl.method13(params.param0, params.param1, params.param2);
        break;
      case _conformanceTestInterfaceMethodMethod14Name:
        var params = _ConformanceTestInterfaceMethod14Params.deserialize(
            message.payload);
        _impl.method14(params.param0);
        break;
      case _conformanceTestInterfaceMethodMethod15Name:
        var params = _ConformanceTestInterfaceMethod15Params.deserialize(
            message.payload);
        _impl.method15(params.param0);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  ConformanceTestInterface get impl => _impl;
  set impl(ConformanceTestInterface d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ConformanceTestInterfaceStubControl($superString)";
  }

  int get version => 0;
}

class ConformanceTestInterfaceStub
    extends bindings.Stub<ConformanceTestInterface>
    implements ConformanceTestInterface,
               ConformanceTestInterfaceInterface,
               ConformanceTestInterfaceInterfaceRequest {
  ConformanceTestInterfaceStub.unbound([ConformanceTestInterface impl])
      : super(new _ConformanceTestInterfaceStubControl.unbound(impl));

  ConformanceTestInterfaceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ConformanceTestInterface impl])
      : super(new _ConformanceTestInterfaceStubControl.fromEndpoint(endpoint, impl));

  ConformanceTestInterfaceStub.fromHandle(
      core.MojoHandle handle, [ConformanceTestInterface impl])
      : super(new _ConformanceTestInterfaceStubControl.fromHandle(handle, impl));

  static ConformanceTestInterfaceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ConformanceTestInterfaceStub"));
    return new ConformanceTestInterfaceStub.fromEndpoint(endpoint);
  }


  void method0(double param0) {
    return impl.method0(param0);
  }
  void method1(StructA param0) {
    return impl.method1(param0);
  }
  void method2(StructB param0, StructA param1) {
    return impl.method2(param0, param1);
  }
  void method3(List<bool> param0) {
    return impl.method3(param0);
  }
  void method4(StructC param0, List<int> param1) {
    return impl.method4(param0, param1);
  }
  void method5(StructE param0, core.MojoDataPipeProducer param1) {
    return impl.method5(param0, param1);
  }
  void method6(List<List<int>> param0) {
    return impl.method6(param0);
  }
  void method7(StructF param0, List<List<int>> param1) {
    return impl.method7(param0, param1);
  }
  void method8(List<List<String>> param0) {
    return impl.method8(param0);
  }
  void method9(List<List<core.MojoHandle>> param0) {
    return impl.method9(param0);
  }
  void method10(Map<String, int> param0) {
    return impl.method10(param0);
  }
  void method11(StructG param0) {
    return impl.method11(param0);
  }
  void method12(double param0,void callback(double param0)) {
    return impl.method12(param0,callback);
  }
  void method13(InterfaceAInterface param0, int param1, InterfaceAInterface param2) {
    return impl.method13(param0, param1, param2);
  }
  void method14(UnionA param0) {
    return impl.method14(param0);
  }
  void method15(StructH param0) {
    return impl.method15(param0);
  }
}

const int _integrationTestInterfaceMethodMethod0Name = 0;

class _IntegrationTestInterfaceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class IntegrationTestInterface {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _IntegrationTestInterfaceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static IntegrationTestInterfaceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    IntegrationTestInterfaceProxy p = new IntegrationTestInterfaceProxy.unbound();
    String name = serviceName ?? IntegrationTestInterface.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void method0(BasicStruct param0,void callback(List<int> param0));
}

abstract class IntegrationTestInterfaceInterface
    implements bindings.MojoInterface<IntegrationTestInterface>,
               IntegrationTestInterface {
  factory IntegrationTestInterfaceInterface([IntegrationTestInterface impl]) =>
      new IntegrationTestInterfaceStub.unbound(impl);

  factory IntegrationTestInterfaceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [IntegrationTestInterface impl]) =>
      new IntegrationTestInterfaceStub.fromEndpoint(endpoint, impl);

  factory IntegrationTestInterfaceInterface.fromMock(
      IntegrationTestInterface mock) =>
      new IntegrationTestInterfaceProxy.fromMock(mock);
}

abstract class IntegrationTestInterfaceInterfaceRequest
    implements bindings.MojoInterface<IntegrationTestInterface>,
               IntegrationTestInterface {
  factory IntegrationTestInterfaceInterfaceRequest() =>
      new IntegrationTestInterfaceProxy.unbound();
}

class _IntegrationTestInterfaceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<IntegrationTestInterface> {
  IntegrationTestInterface impl;

  _IntegrationTestInterfaceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _IntegrationTestInterfaceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _IntegrationTestInterfaceProxyControl.unbound() : super.unbound();

  String get serviceName => IntegrationTestInterface.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _integrationTestInterfaceMethodMethod0Name:
        var r = IntegrationTestInterfaceMethod0ResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.param0 );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_IntegrationTestInterfaceProxyControl($superString)";
  }
}

class IntegrationTestInterfaceProxy
    extends bindings.Proxy<IntegrationTestInterface>
    implements IntegrationTestInterface,
               IntegrationTestInterfaceInterface,
               IntegrationTestInterfaceInterfaceRequest {
  IntegrationTestInterfaceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _IntegrationTestInterfaceProxyControl.fromEndpoint(endpoint));

  IntegrationTestInterfaceProxy.fromHandle(core.MojoHandle handle)
      : super(new _IntegrationTestInterfaceProxyControl.fromHandle(handle));

  IntegrationTestInterfaceProxy.unbound()
      : super(new _IntegrationTestInterfaceProxyControl.unbound());

  factory IntegrationTestInterfaceProxy.fromMock(IntegrationTestInterface mock) {
    IntegrationTestInterfaceProxy newMockedProxy =
        new IntegrationTestInterfaceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static IntegrationTestInterfaceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For IntegrationTestInterfaceProxy"));
    return new IntegrationTestInterfaceProxy.fromEndpoint(endpoint);
  }


  void method0(BasicStruct param0,void callback(List<int> param0)) {
    if (impl != null) {
      impl.method0(param0,callback);
      return;
    }
    var params = new _IntegrationTestInterfaceMethod0Params();
    params.param0 = param0;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((List<int> param0) {
        z.bindCallback(() {
          callback(param0);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _integrationTestInterfaceMethodMethod0Name,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _IntegrationTestInterfaceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<IntegrationTestInterface> {
  IntegrationTestInterface _impl;

  _IntegrationTestInterfaceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [IntegrationTestInterface impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _IntegrationTestInterfaceStubControl.fromHandle(
      core.MojoHandle handle, [IntegrationTestInterface impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _IntegrationTestInterfaceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => IntegrationTestInterface.serviceName;


  Function _integrationTestInterfaceMethod0ResponseParamsResponder(
      int requestId) {
  return (List<int> param0) {
      var result = new IntegrationTestInterfaceMethod0ResponseParams();
      result.param0 = param0;
      sendResponse(buildResponseWithId(
          result,
          _integrationTestInterfaceMethodMethod0Name,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _integrationTestInterfaceMethodMethod0Name:
        var params = _IntegrationTestInterfaceMethod0Params.deserialize(
            message.payload);
        _impl.method0(params.param0, _integrationTestInterfaceMethod0ResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  IntegrationTestInterface get impl => _impl;
  set impl(IntegrationTestInterface d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_IntegrationTestInterfaceStubControl($superString)";
  }

  int get version => 0;
}

class IntegrationTestInterfaceStub
    extends bindings.Stub<IntegrationTestInterface>
    implements IntegrationTestInterface,
               IntegrationTestInterfaceInterface,
               IntegrationTestInterfaceInterfaceRequest {
  IntegrationTestInterfaceStub.unbound([IntegrationTestInterface impl])
      : super(new _IntegrationTestInterfaceStubControl.unbound(impl));

  IntegrationTestInterfaceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [IntegrationTestInterface impl])
      : super(new _IntegrationTestInterfaceStubControl.fromEndpoint(endpoint, impl));

  IntegrationTestInterfaceStub.fromHandle(
      core.MojoHandle handle, [IntegrationTestInterface impl])
      : super(new _IntegrationTestInterfaceStubControl.fromHandle(handle, impl));

  static IntegrationTestInterfaceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For IntegrationTestInterfaceStub"));
    return new IntegrationTestInterfaceStub.fromEndpoint(endpoint);
  }


  void method0(BasicStruct param0,void callback(List<int> param0)) {
    return impl.method0(param0,callback);
  }
}


mojom_types.RuntimeTypeInfo getRuntimeTypeInfo() => _runtimeTypeInfo ??
    _initRuntimeTypeInfo();

Map<String, mojom_types.UserDefinedType> getAllMojomTypeDefinitions() {
  return getRuntimeTypeInfo().typeMap;
}

var _runtimeTypeInfo;
mojom_types.RuntimeTypeInfo  _initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this
  // file. The string contains the base64 encoding of the gzip-compressed bytes.
  var serializedRuntimeTypeInfo = "H4sIAAAJbogC/+xdy3Pbxhlf8CFRD9t0Eru0W3toO3ZlJyGply17xi1FirY6qTtK/JKbJhRNQSISkZQJMlHczlS3tqf66EtnfPTRRx9zzNFHH/Un+KhLpgHEby1gsUssSIBYSMRkvVloQQC/7/3tYjeB2kcc6tdQk+eXDW1JKzFo39TKrFaaFUVNaf81K3JKlRvfK2U5VStV5dRavZHK1Vu1VTVfkcvf3ZPV5p9qTbmxVirLlN+b1sonWrn3aKlQ/Lzw6Ea1/m091dSu6vQr1ud9HW7Xz7XygVaewflXUL+Beu/m2pGBegXqbahfQP0T1DtQo1C7SkKdhXoF6m2oX0L9FupdqD/Wyu8Y71lSlXKh1qrq/S5p5WyHfnebjVa52T1uHa7L12sa8aqlWll2dJ3ecb1Rair1mvW6i1o5w75ur+O89vfzWjlN79d+5fk2jrb9cpz98pz9Fjj7FTj73eLsd5uz32K732WtnOvU76HSrGAm044ZrXzK0z+l/6M3lBqCe5yiX3e/pnEAkMm2H5AJTUhtecVynJDMeud5bL+ti3hszNzeOmlu735tbr+Szb+3u2ZuryjmdnLD3H5ZM7cXn5jbSy1ze+cHczv7T3P7xb/MemvxP/ttXVW8+K+5XfkfXT/HAacsMh8ZZD7/fziWEP04rpURrZiUkHb8VisfaoWhpizPo5+NakXVyndaSbfURnqjXi5tpNfr9fUNOV2pV+X000Yprf/kVFptlPf+L73ZeryhlNMK1gZq+rFSW1Vq62pav6+a/r60oazuqZeifqK43zOl/0D1/Xvr95/AuAI+FdC/O2Af4lHgO+iXRJ0PFr5zBL6LjOtHgO5YLnRdeIKOa2qegmsN+MAvXO1wklzGKceBU46CU10wnLD8Yjl1m5/yHDjlKTht+oxTkvA3kzbywus30fA36slfNEzdxH+BA/8FCv5PfMYf28VfEEI8uI26zLcFDtwKFNwaguA2SuCVIPwWHBf0apd12zuG7TJ2+tm4ve9B4lbWyrDPuBnjvSzBN/g5o4jvYOGKDLga+ZrFhyVG3LsKzyoKXgnC1sYZcovj1V2GvZkj4v03BB++Y+BFPk+Sgtuw4Tzm27vtnMBfSlXZlbxBEu7J6nIFYiXOMNhC989Btv2ie6/4kO+TIPwQzD8J7JdgPmD4w7tQL4Xdlb9jwC935GalvpqxPPefBfNPMA7JEP/760eG8f6/AQzg/T9ryE9a2sNYcMCH6Hp7uE96+6hWhnT/tdQoVTOIyjfxAOhtr/krAffa5y91s15T5QF/9c5f5wPoF+w6jNeNeEncenzSgtedQ6XHJwd63CU5uxMQPc7Ki2U48z2LBJ9VGHhhv5c1OGP1ezsO41jwXvLZ76U9D8YnbsA9BPF3BGLFIeDZGMR0oxB3jGvlCPCZLp//ht/ZRuY88HNg+DfjcF+42dIJoNtp6H8GLrwA44mXYNzvCpxPQVw1CeOA19r1u5swHjjPp5f75V9/MfCvA6WXQ4Lo5S8Cqpf98n++FFTOtgb+j0XOdHsSk8SQsy9h/orffIMY+STM93hSBu+8DbfkN+SADiFu+Z2y0OGuoPK7G/ZCfqeElV8yX7ktBUOO7wZKjnPc86qc4h7rAneJF/dJOu7nD5n+DBnadvoz7IAOYW79OW2hwz1B9WfWE/9nOtD+T0ggvanzzUlB5Fd/l7jNeGi3fkzEAZ4RbjmcseB5X1A5/MkTP2Zm4Me4LI/3A+XH5LnnfTvVg/32Y3Tcfy+gHhxG7vojUQd4Rrn14KwFzweC6sFXnujB2YEedFkPPgiUHixwf69Cwz0ikB58APOi/PSfjbGTW3pvyAF+Q9x676oFv4eC6r0VT+Kwq4M4zCV9p/PNWcH8jxCyzkPtxj9xEqcNO8B7mFtOr1G/txVRTnc88U+uDfwTl+V1OVD+yS3u72RFj9OWffZPkoT/wdKTksF/8SKOiznAO8atJ+cseD8SVE9ueuLPzA38GZf04yOgnej+jGT4uxFfr/LQIw7wH+GW2+sW/P96qOT2+kBuXZJbnW/OCcA3koM4JEKRW8lluR11gP9oB/zj8CwwjytD4v/VAc8fmL+XmXw/YTSIchsWSG6/8jl/kGHYS/I5hz22r2MO8B7jl9NJ8j3+hg72fFNCTieDLKci5Q10vvkwMHmD29zrZvUqv/i753EHdBjnl98pkg5fo4P9XQYhv1NBll+cGxFBfnW+OY6C990zdognHPLXHAOnU4CDgb/aHz4T9x3wWfd8dgEF//ufIw7wOsKvz6dJvL4RVJ9nop7o82lR9XkS4iL8XM9A77wMBcM/+wZySyLkPxBFn38AuQjTYq6If91Xlt4bQWKM7+j4X/IRf6f8Od4FPiFefKbo+Nw4wPzZye6EDfexsztHHdDjKL/dmSHpUTxceYCZQR7AHTtTFHz+AH5+vMg07zrUdn4j7/j2MQd0OMYvv7MkHVYOl/zODuTXHfldCVQeb5F7XXtR1+NhbXpgXY+n4/YIFjquI7HW40kY/Eqpw/gIS3++6vP6kRVB9ef2YH0bofWnzjcnBdSf+DxrPWje/WJ6XZ8yO1ifUuh5Mjr/plEwvxfkseMJTjueJfiQtb46Ky+g7zXwkcV+7/cgcV8QzF7HiTwZc91uwHPORq551/cn17XA4zGM5Swszx1DwVinfrRP4zF4nXqFgdcIlKCN+2G+e+YJ3+WYfJdj4DgeAL7rp5+E8xPqHmrFEonXEZ/1nbM40/31yVj8vOwJP+eZ/Jxn8HM8APzcT79Jl299Pq724CUaXscB86D7TSy+3PSELxeYfLnA4MuPAsKXcZf5khUHnQBdWpVVtbQuFzeVTVml4HYCifcdLm1+u5Efe+HXt2Ev+LXA5NcCg18TPvOrqN+hEv7BKonbqUD5Bwvc+7/ScI9Q4tJe5ymw5redhphVt2N7yqJYrtfUVlVu0Pn3NIxvi7BuRgjxf2fK0gsrntixW0y9cIuhF84M7Bg1n7embMmrRVV5KhdLjUbpRxK3swKNLzv9DprHbr0b8oI/bzP58zaDP8/5zJ8ToBcxTnMYH7xfeqRzfiUqSH7lPPJ3H0CWnV+ysTcSQy9sMezNZgc7b7fvX9hwP5xPvaPUHsgNVXs5vnzCBbBVos0f6zWfQKOf1IF+cYNu4qVfyAX6hW3oNwZ9NPpR5eRj8Pn89jMkm7wt64h0gXu4D7hj/fSYoZ8uCjBeGabMn5qzsZ8Jwzmj35cw0MFoP1j2NhPzwt4uMu3tIoMOEz7bW3Lf+yyRj/wZGG052p18eGV3WfvvXvYZTxY+rP3RpC7jPDt8WHJ/RVC/xM31mEIc+JQZ+HwiSP6B5U90O4/VaR490QXuYQ7cVxm4f4r8/Q7RiDvOU0YRfZ0Or+nSaR2GZBd0iXDQhfWd42c++wkZhjwMk/rDYzp1iu+jhuck/Y0tyVw7nXfyluh/Et6h7VU8VJqVQq1V3Z9XSvoduAdJ1x8EyE/T/AcS5xnQDcx4Cb9gSv9Hbyg1RIwvsOiGKOff7yPpkF4rRL8dwj83P13bzlzoQC/idSzPt+Uz/S5DrsiWLgY/1+iXY3zxvFY8z5c1f4vXjyT99mUbvTdv0HMX+eiRmqfQ40d4Pz/zZp1wk1zGLdcFbjkKbk8Fxy3kMm75LnDLU3D7u+C4hV3GbaEL3BYouP3DZ9wsdk9yhlOWgRPp1+BxFdKdIe+fgev8wmMZ7OMSYReWQPBeAiP9DIm2GIyTrIAD+BoM+Fv44DsxRrcj8R7iyV7yEZM+z7Nk4TDCaRfcyjtMCYiD7re/49TzbuUXpiEnftDGK2j4hgz4hvuUR5hB/u4zTcsjGONVGk5hA06RPsX1swLG9U7WV7STZ7f2hcI4rjFwvBqkfGHOPt+R48TXrf1nML7rDHyvoYM5X9xOX7q1bwjGt8LAdw6JPX/ZTl+6tW+A3XyO66g9lzao69HaybNb67hjHL9l4HjDZz/QUX7Ygb7sS1yXY8Z1OfL+N32O68h8XxLwwOuBJsNixWl/GMRpe8cfBcVhtM9xWlZwfuhXPDXvMw6/BgAA///BgM46cKgAAA==";

  // Deserialize RuntimeTypeInfo
  var bytes = BASE64.decode(serializedRuntimeTypeInfo);
  var unzippedBytes = new ZLibDecoder().convert(bytes);
  var bdata = new ByteData.view(unzippedBytes.buffer);
  var message = new bindings.Message(bdata, null, unzippedBytes.length, 0);
  _runtimeTypeInfo = mojom_types.RuntimeTypeInfo.deserialize(message);
  return _runtimeTypeInfo;
}
