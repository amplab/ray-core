// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library cookie_store_mojom;
import 'dart:async';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;



class _CookieStoreGetParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String url = null;

  _CookieStoreGetParams() : super(kVersions.last.size);

  _CookieStoreGetParams.init(
    String this.url
  ) : super(kVersions.last.size);

  static _CookieStoreGetParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CookieStoreGetParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CookieStoreGetParams result = new _CookieStoreGetParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.url = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CookieStoreGetParams";
    String fieldName;
    try {
      fieldName = "url";
      encoder0.encodeString(url, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CookieStoreGetParams("
           "url: $url" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["url"] = url;
    return map;
  }
}


class CookieStoreGetResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String cookies = null;

  CookieStoreGetResponseParams() : super(kVersions.last.size);

  CookieStoreGetResponseParams.init(
    String this.cookies
  ) : super(kVersions.last.size);

  static CookieStoreGetResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CookieStoreGetResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CookieStoreGetResponseParams result = new CookieStoreGetResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.cookies = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CookieStoreGetResponseParams";
    String fieldName;
    try {
      fieldName = "cookies";
      encoder0.encodeString(cookies, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CookieStoreGetResponseParams("
           "cookies: $cookies" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["cookies"] = cookies;
    return map;
  }
}


class _CookieStoreSetParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  String url = null;
  String cookie = null;

  _CookieStoreSetParams() : super(kVersions.last.size);

  _CookieStoreSetParams.init(
    String this.url, 
    String this.cookie
  ) : super(kVersions.last.size);

  static _CookieStoreSetParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CookieStoreSetParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CookieStoreSetParams result = new _CookieStoreSetParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.url = decoder0.decodeString(8, false);
    }
    if (mainDataHeader.version >= 0) {
      
      result.cookie = decoder0.decodeString(16, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CookieStoreSetParams";
    String fieldName;
    try {
      fieldName = "url";
      encoder0.encodeString(url, 8, false);
      fieldName = "cookie";
      encoder0.encodeString(cookie, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CookieStoreSetParams("
           "url: $url" ", "
           "cookie: $cookie" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["url"] = url;
    map["cookie"] = cookie;
    return map;
  }
}


class CookieStoreSetResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool success = false;

  CookieStoreSetResponseParams() : super(kVersions.last.size);

  CookieStoreSetResponseParams.init(
    bool this.success
  ) : super(kVersions.last.size);

  static CookieStoreSetResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CookieStoreSetResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CookieStoreSetResponseParams result = new CookieStoreSetResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.success = decoder0.decodeBool(8, 0);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CookieStoreSetResponseParams";
    String fieldName;
    try {
      fieldName = "success";
      encoder0.encodeBool(success, 8, 0);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CookieStoreSetResponseParams("
           "success: $success" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["success"] = success;
    return map;
  }
}

const int _cookieStoreMethodGetName = 0;
const int _cookieStoreMethodSetName = 1;

class _CookieStoreServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CookieStore {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CookieStoreServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CookieStoreProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CookieStoreProxy p = new CookieStoreProxy.unbound();
    String name = serviceName ?? CookieStore.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void get(String url,void callback(String cookies));
  void set(String url,String cookie,void callback(bool success));
}

abstract class CookieStoreInterface
    implements bindings.MojoInterface<CookieStore>,
               CookieStore {
  factory CookieStoreInterface([CookieStore impl]) =>
      new CookieStoreStub.unbound(impl);

  factory CookieStoreInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CookieStore impl]) =>
      new CookieStoreStub.fromEndpoint(endpoint, impl);

  factory CookieStoreInterface.fromMock(
      CookieStore mock) =>
      new CookieStoreProxy.fromMock(mock);
}

abstract class CookieStoreInterfaceRequest
    implements bindings.MojoInterface<CookieStore>,
               CookieStore {
  factory CookieStoreInterfaceRequest() =>
      new CookieStoreProxy.unbound();
}

class _CookieStoreProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CookieStore> {
  CookieStore impl;

  _CookieStoreProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CookieStoreProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CookieStoreProxyControl.unbound() : super.unbound();

  String get serviceName => CookieStore.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _cookieStoreMethodGetName:
        var r = CookieStoreGetResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.cookies );
        break;
      case _cookieStoreMethodSetName:
        var r = CookieStoreSetResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.success );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CookieStoreProxyControl($superString)";
  }
}

class CookieStoreProxy
    extends bindings.Proxy<CookieStore>
    implements CookieStore,
               CookieStoreInterface,
               CookieStoreInterfaceRequest {
  CookieStoreProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CookieStoreProxyControl.fromEndpoint(endpoint));

  CookieStoreProxy.fromHandle(core.MojoHandle handle)
      : super(new _CookieStoreProxyControl.fromHandle(handle));

  CookieStoreProxy.unbound()
      : super(new _CookieStoreProxyControl.unbound());

  factory CookieStoreProxy.fromMock(CookieStore mock) {
    CookieStoreProxy newMockedProxy =
        new CookieStoreProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CookieStoreProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CookieStoreProxy"));
    return new CookieStoreProxy.fromEndpoint(endpoint);
  }


  void get(String url,void callback(String cookies)) {
    if (impl != null) {
      impl.get(url,callback);
      return;
    }
    var params = new _CookieStoreGetParams();
    params.url = url;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((String cookies) {
        z.bindCallback(() {
          callback(cookies);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _cookieStoreMethodGetName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void set(String url,String cookie,void callback(bool success)) {
    if (impl != null) {
      impl.set(url,cookie,callback);
      return;
    }
    var params = new _CookieStoreSetParams();
    params.url = url;
    params.cookie = cookie;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((bool success) {
        z.bindCallback(() {
          callback(success);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _cookieStoreMethodSetName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _CookieStoreStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CookieStore> {
  CookieStore _impl;

  _CookieStoreStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CookieStore impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CookieStoreStubControl.fromHandle(
      core.MojoHandle handle, [CookieStore impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CookieStoreStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CookieStore.serviceName;


  Function _cookieStoreGetResponseParamsResponder(
      int requestId) {
  return (String cookies) {
      var result = new CookieStoreGetResponseParams();
      result.cookies = cookies;
      sendResponse(buildResponseWithId(
          result,
          _cookieStoreMethodGetName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _cookieStoreSetResponseParamsResponder(
      int requestId) {
  return (bool success) {
      var result = new CookieStoreSetResponseParams();
      result.success = success;
      sendResponse(buildResponseWithId(
          result,
          _cookieStoreMethodSetName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _cookieStoreMethodGetName:
        var params = _CookieStoreGetParams.deserialize(
            message.payload);
        _impl.get(params.url, _cookieStoreGetResponseParamsResponder(message.header.requestId));
        break;
      case _cookieStoreMethodSetName:
        var params = _CookieStoreSetParams.deserialize(
            message.payload);
        _impl.set(params.url, params.cookie, _cookieStoreSetResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CookieStore get impl => _impl;
  set impl(CookieStore d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CookieStoreStubControl($superString)";
  }

  int get version => 0;
}

class CookieStoreStub
    extends bindings.Stub<CookieStore>
    implements CookieStore,
               CookieStoreInterface,
               CookieStoreInterfaceRequest {
  CookieStoreStub.unbound([CookieStore impl])
      : super(new _CookieStoreStubControl.unbound(impl));

  CookieStoreStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CookieStore impl])
      : super(new _CookieStoreStubControl.fromEndpoint(endpoint, impl));

  CookieStoreStub.fromHandle(
      core.MojoHandle handle, [CookieStore impl])
      : super(new _CookieStoreStubControl.fromHandle(handle, impl));

  static CookieStoreStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CookieStoreStub"));
    return new CookieStoreStub.fromEndpoint(endpoint);
  }


  void get(String url,void callback(String cookies)) {
    return impl.get(url,callback);
  }
  void set(String url,String cookie,void callback(bool success)) {
    return impl.set(url,cookie,callback);
  }
}



