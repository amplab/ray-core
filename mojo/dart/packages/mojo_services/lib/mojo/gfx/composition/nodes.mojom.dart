// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library nodes_mojom;
import 'package:mojo/bindings.dart' as bindings;

import 'package:mojo_services/mojo/geometry.mojom.dart' as geometry_mojom;
import 'package:mojo_services/mojo/gfx/composition/hit_tests.mojom.dart' as hit_tests_mojom;



class NodeCombinator extends bindings.MojoEnum {
  static const NodeCombinator merge = const NodeCombinator._(0);
  static const NodeCombinator prune = const NodeCombinator._(1);
  static const NodeCombinator fallback = const NodeCombinator._(2);

  const NodeCombinator._(int v) : super(v);

  static const Map<String, NodeCombinator> valuesMap = const {
    "merge": merge,
    "prune": prune,
    "fallback": fallback,
  };
  static const List<NodeCombinator> values = const [
    merge,
    prune,
    fallback,
  ];

  static NodeCombinator valueOf(String name) => valuesMap[name];

  factory NodeCombinator(int v) {
    switch (v) {
      case 0:
        return NodeCombinator.merge;
      case 1:
        return NodeCombinator.prune;
      case 2:
        return NodeCombinator.fallback;
      default:
        return null;
    }
  }

  static NodeCombinator decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    NodeCombinator result = new NodeCombinator(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum NodeCombinator.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case merge:
        return 'NodeCombinator.merge';
      case prune:
        return 'NodeCombinator.prune';
      case fallback:
        return 'NodeCombinator.fallback';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class Node extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(64, 0)
  ];
  geometry_mojom.Transform contentTransform = null;
  geometry_mojom.RectF contentClip = null;
  NodeCombinator combinator = new NodeCombinator(0);
  hit_tests_mojom.HitTestBehavior hitTestBehavior = null;
  List<int> childNodeIds = null;
  NodeOp op = null;

  Node() : super(kVersions.last.size);

  Node.init(
    geometry_mojom.Transform this.contentTransform, 
    geometry_mojom.RectF this.contentClip, 
    NodeCombinator this.combinator, 
    hit_tests_mojom.HitTestBehavior this.hitTestBehavior, 
    List<int> this.childNodeIds, 
    NodeOp this.op
  ) : super(kVersions.last.size);

  static Node deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Node decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Node result = new Node();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.contentTransform = geometry_mojom.Transform.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.contentClip = geometry_mojom.RectF.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
        result.combinator = NodeCombinator.decode(decoder0, 24);
        if (result.combinator == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable NodeCombinator.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(32, true);
      result.hitTestBehavior = hit_tests_mojom.HitTestBehavior.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.childNodeIds = decoder0.decodeUint32Array(40, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
        result.op = NodeOp.decode(decoder0, 48);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Node";
    String fieldName;
    try {
      fieldName = "contentTransform";
      encoder0.encodeStruct(contentTransform, 8, true);
      fieldName = "contentClip";
      encoder0.encodeStruct(contentClip, 16, true);
      fieldName = "combinator";
      encoder0.encodeEnum(combinator, 24);
      fieldName = "hitTestBehavior";
      encoder0.encodeStruct(hitTestBehavior, 32, true);
      fieldName = "childNodeIds";
      encoder0.encodeUint32Array(childNodeIds, 40, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "op";
      encoder0.encodeUnion(op, 48, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Node("
           "contentTransform: $contentTransform" ", "
           "contentClip: $contentClip" ", "
           "combinator: $combinator" ", "
           "hitTestBehavior: $hitTestBehavior" ", "
           "childNodeIds: $childNodeIds" ", "
           "op: $op" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["contentTransform"] = contentTransform;
    map["contentClip"] = contentClip;
    map["combinator"] = combinator;
    map["hitTestBehavior"] = hitTestBehavior;
    map["childNodeIds"] = childNodeIds;
    map["op"] = op;
    return map;
  }
}


class RectNodeOp extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  geometry_mojom.RectF contentRect = null;
  Color color = null;

  RectNodeOp() : super(kVersions.last.size);

  RectNodeOp.init(
    geometry_mojom.RectF this.contentRect, 
    Color this.color
  ) : super(kVersions.last.size);

  static RectNodeOp deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static RectNodeOp decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    RectNodeOp result = new RectNodeOp();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.contentRect = geometry_mojom.RectF.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, false);
      result.color = Color.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "RectNodeOp";
    String fieldName;
    try {
      fieldName = "contentRect";
      encoder0.encodeStruct(contentRect, 8, false);
      fieldName = "color";
      encoder0.encodeStruct(color, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "RectNodeOp("
           "contentRect: $contentRect" ", "
           "color: $color" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["contentRect"] = contentRect;
    map["color"] = color;
    return map;
  }
}


class ImageNodeOp extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(40, 0)
  ];
  geometry_mojom.RectF contentRect = null;
  geometry_mojom.RectF imageRect = null;
  int imageResourceId = 0;
  Blend blend = null;

  ImageNodeOp() : super(kVersions.last.size);

  ImageNodeOp.init(
    geometry_mojom.RectF this.contentRect, 
    geometry_mojom.RectF this.imageRect, 
    int this.imageResourceId, 
    Blend this.blend
  ) : super(kVersions.last.size);

  static ImageNodeOp deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ImageNodeOp decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ImageNodeOp result = new ImageNodeOp();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.contentRect = geometry_mojom.RectF.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.imageRect = geometry_mojom.RectF.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.imageResourceId = decoder0.decodeUint32(24);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(32, true);
      result.blend = Blend.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ImageNodeOp";
    String fieldName;
    try {
      fieldName = "contentRect";
      encoder0.encodeStruct(contentRect, 8, false);
      fieldName = "imageRect";
      encoder0.encodeStruct(imageRect, 16, true);
      fieldName = "imageResourceId";
      encoder0.encodeUint32(imageResourceId, 24);
      fieldName = "blend";
      encoder0.encodeStruct(blend, 32, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ImageNodeOp("
           "contentRect: $contentRect" ", "
           "imageRect: $imageRect" ", "
           "imageResourceId: $imageResourceId" ", "
           "blend: $blend" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["contentRect"] = contentRect;
    map["imageRect"] = imageRect;
    map["imageResourceId"] = imageResourceId;
    map["blend"] = blend;
    return map;
  }
}


class SceneNodeOp extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int sceneResourceId = 0;
  int sceneVersion = 0;

  SceneNodeOp() : super(kVersions.last.size);

  SceneNodeOp.init(
    int this.sceneResourceId, 
    int this.sceneVersion
  ) : super(kVersions.last.size);

  static SceneNodeOp deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static SceneNodeOp decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    SceneNodeOp result = new SceneNodeOp();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.sceneResourceId = decoder0.decodeUint32(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.sceneVersion = decoder0.decodeUint32(12);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "SceneNodeOp";
    String fieldName;
    try {
      fieldName = "sceneResourceId";
      encoder0.encodeUint32(sceneResourceId, 8);
      fieldName = "sceneVersion";
      encoder0.encodeUint32(sceneVersion, 12);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "SceneNodeOp("
           "sceneResourceId: $sceneResourceId" ", "
           "sceneVersion: $sceneVersion" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["sceneResourceId"] = sceneResourceId;
    map["sceneVersion"] = sceneVersion;
    return map;
  }
}


class LayerNodeOp extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  geometry_mojom.RectF layerRect = null;
  Blend blend = null;

  LayerNodeOp() : super(kVersions.last.size);

  LayerNodeOp.init(
    geometry_mojom.RectF this.layerRect, 
    Blend this.blend
  ) : super(kVersions.last.size);

  static LayerNodeOp deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static LayerNodeOp decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    LayerNodeOp result = new LayerNodeOp();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.layerRect = geometry_mojom.RectF.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.blend = Blend.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "LayerNodeOp";
    String fieldName;
    try {
      fieldName = "layerRect";
      encoder0.encodeStruct(layerRect, 8, false);
      fieldName = "blend";
      encoder0.encodeStruct(blend, 16, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "LayerNodeOp("
           "layerRect: $layerRect" ", "
           "blend: $blend" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["layerRect"] = layerRect;
    map["blend"] = blend;
    return map;
  }
}


class Color extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int red = 0;
  int green = 0;
  int blue = 0;
  int alpha = 0;

  Color() : super(kVersions.last.size);

  Color.init(
    int this.red, 
    int this.green, 
    int this.blue, 
    int this.alpha
  ) : super(kVersions.last.size);

  static Color deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Color decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Color result = new Color();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.red = decoder0.decodeUint8(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.green = decoder0.decodeUint8(9);
    }
    if (mainDataHeader.version >= 0) {
      
      result.blue = decoder0.decodeUint8(10);
    }
    if (mainDataHeader.version >= 0) {
      
      result.alpha = decoder0.decodeUint8(11);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Color";
    String fieldName;
    try {
      fieldName = "red";
      encoder0.encodeUint8(red, 8);
      fieldName = "green";
      encoder0.encodeUint8(green, 9);
      fieldName = "blue";
      encoder0.encodeUint8(blue, 10);
      fieldName = "alpha";
      encoder0.encodeUint8(alpha, 11);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Color("
           "red: $red" ", "
           "green: $green" ", "
           "blue: $blue" ", "
           "alpha: $alpha" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["red"] = red;
    map["green"] = green;
    map["blue"] = blue;
    map["alpha"] = alpha;
    return map;
  }
}


class Blend extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int alpha = 255;

  Blend() : super(kVersions.last.size);

  Blend.init(
    int this.alpha
  ) : super(kVersions.last.size);

  static Blend deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Blend decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Blend result = new Blend();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.alpha = decoder0.decodeUint8(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Blend";
    String fieldName;
    try {
      fieldName = "alpha";
      encoder0.encodeUint8(alpha, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Blend("
           "alpha: $alpha" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["alpha"] = alpha;
    return map;
  }
}



enum NodeOpTag {
  rect,
  image,
  scene,
  layer,
  unknown
}

class NodeOp extends bindings.Union {
  static final _tagToInt = const {
    NodeOpTag.rect: 0,
    NodeOpTag.image: 1,
    NodeOpTag.scene: 2,
    NodeOpTag.layer: 3,
  };

  static final _intToTag = const {
    0: NodeOpTag.rect,
    1: NodeOpTag.image,
    2: NodeOpTag.scene,
    3: NodeOpTag.layer,
  };

  var _data;
  NodeOpTag _tag = NodeOpTag.unknown;

  NodeOpTag get tag => _tag;
  RectNodeOp get rect {
    if (_tag != NodeOpTag.rect) {
      throw new bindings.UnsetUnionTagError(_tag, NodeOpTag.rect);
    }
    return _data;
  }

  set rect(RectNodeOp value) {
    _tag = NodeOpTag.rect;
    _data = value;
  }
  ImageNodeOp get image {
    if (_tag != NodeOpTag.image) {
      throw new bindings.UnsetUnionTagError(_tag, NodeOpTag.image);
    }
    return _data;
  }

  set image(ImageNodeOp value) {
    _tag = NodeOpTag.image;
    _data = value;
  }
  SceneNodeOp get scene {
    if (_tag != NodeOpTag.scene) {
      throw new bindings.UnsetUnionTagError(_tag, NodeOpTag.scene);
    }
    return _data;
  }

  set scene(SceneNodeOp value) {
    _tag = NodeOpTag.scene;
    _data = value;
  }
  LayerNodeOp get layer {
    if (_tag != NodeOpTag.layer) {
      throw new bindings.UnsetUnionTagError(_tag, NodeOpTag.layer);
    }
    return _data;
  }

  set layer(LayerNodeOp value) {
    _tag = NodeOpTag.layer;
    _data = value;
  }

  static NodeOp decode(bindings.Decoder decoder0, int offset) {
    int size = decoder0.decodeUint32(offset);
    if (size == 0) {
      return null;
    }
    NodeOp result = new NodeOp();

    
    NodeOpTag tag = _intToTag[decoder0.decodeUint32(offset + 4)];
    switch (tag) {
      case NodeOpTag.rect:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.rect = RectNodeOp.decode(decoder1);
        break;
      case NodeOpTag.image:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.image = ImageNodeOp.decode(decoder1);
        break;
      case NodeOpTag.scene:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.scene = SceneNodeOp.decode(decoder1);
        break;
      case NodeOpTag.layer:
        
        var decoder1 = decoder0.decodePointer(offset + 8, false);
        result.layer = LayerNodeOp.decode(decoder1);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $tag");
    }

    return result;
  }

  void encode(bindings.Encoder encoder0, int offset) {
    
    encoder0.encodeUint32(16, offset);
    encoder0.encodeUint32(_tagToInt[_tag], offset + 4);
    switch (_tag) {
      case NodeOpTag.rect:
        encoder0.encodeStruct(rect, offset + 8, false);
        break;
      case NodeOpTag.image:
        encoder0.encodeStruct(image, offset + 8, false);
        break;
      case NodeOpTag.scene:
        encoder0.encodeStruct(scene, offset + 8, false);
        break;
      case NodeOpTag.layer:
        encoder0.encodeStruct(layer, offset + 8, false);
        break;
      default:
        throw new bindings.MojoCodecError("Bad union tag: $_tag");
    }
  }

  String toString() {
    String result = "NodeOp(";
    switch (_tag) {
      case NodeOpTag.rect:
        result += "rect";
        break;
      case NodeOpTag.image:
        result += "image";
        break;
      case NodeOpTag.scene:
        result += "scene";
        break;
      case NodeOpTag.layer:
        result += "layer";
        break;
      default:
        result += "unknown";
    }
    result += ": $_data)";
    return result;
  }
}


