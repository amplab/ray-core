{%- import "interface_macros.tmpl" as interface_macros -%}
{%- import "struct_macros.tmpl" as struct_macros -%}

// NOTE: This file was generated by the Mojo bindings generator.
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "{{module.path}}-sync.h"

#include <math.h>
#include <ostream>
#include <string>
#include <utility>

#include "mojo/public/cpp/bindings/lib/array_serialization.h"
#include "mojo/public/cpp/bindings/lib/bindings_serialization.h"
#include "mojo/public/cpp/bindings/lib/bounds_checker.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/map_serialization.h"
#include "mojo/public/cpp/bindings/lib/message_builder.h"
#include "mojo/public/cpp/bindings/lib/message_validation.h"
#include "mojo/public/cpp/bindings/lib/string_serialization.h"
#include "mojo/public/cpp/bindings/lib/synchronous_connector.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "mojo/public/cpp/bindings/message.h"
#include "mojo/public/cpp/bindings/message_validator.h"
#include "mojo/public/cpp/environment/logging.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "{{module.path}}-internal.h"
#include "{{module.path}}-common.h"

{%- for namespace in namespaces_as_array %}
namespace {{namespace}} {
{%- endfor %}

// --- Interface definitions ---
{% for interface in interfaces %}
{%- set base_name = "internal::%s_Base"|format(interface.name) -%}
{{interface.name}}_SynchronousProxy::{{interface.name}}_SynchronousProxy(
      mojo::internal::SynchronousConnector* connector,
      mojo::internal::MessageValidatorList&& validators)
          : connector_(connector), validators_(std::move(validators)) {
}

{% for method in interface.methods %}
{%-   set message_name =
          "%s::MessageOrdinals::%s"|format(base_name, method.name) %}
{%-   set params_struct = method.param_struct %}
{%-   set params_description =
          "%s.%s request"|format(interface.name, method.name) %}
bool {{interface.name}}_SynchronousProxy::{{method.name}}(
    {{- interface_macros.declare_sync_request_params(method)}})
    {%- if method.response_parameters == None %} const {% endif %} {
  {{struct_macros.get_serialized_size(params_struct, "in_%s")}}

  auto msg_name = static_cast<uint32_t>({{message_name}});
{%-   if method.response_parameters != None %}
  mojo::RequestMessageBuilder builder(msg_name, size);
{%-   else %}
  mojo::MessageBuilder builder(msg_name, size);
{%-   endif %}

  {{struct_macros.serialize(params_struct,
                            "{{interface.name}}::{{method.name}}", "in_%s",
                            "out_params", "builder.buffer()", false)}}
  out_params->EncodePointersAndHandles(builder.message()->mutable_handles());
  
  if (!connector_->Write(builder.message()))
    return false;
  
{%-   if method.response_parameters != None %}
  mojo::Message response_msg;
  if (!connector_->BlockingRead(&response_msg))
    return false; 
  
  // Validate the incoming message.
  std::string response_err;
  if (mojo::internal::RunValidatorsOnMessage(validators_, &response_msg,
                                             &response_err)
        != mojo::internal::ValidationError::NONE) {
    MOJO_LOG(WARNING) << response_err;
    return false;
  }
  
{#- TODO(vardhan): Add support for synchronous control messages. #} 
  if (mojo::internal::ControlMessageHandler::IsControlMessage(&response_msg)) {
    MOJO_LOG(ERROR) << "Synchronous interface bindings currently don't support "
                       "interface control messages.";
    return false;
  }
  if (response_msg.name() != msg_name) {
    MOJO_LOG(ERROR) << "Expecting response for message = " << msg_name <<
                       ", but received message = " << response_msg.name();
    return false;
  }
  
  internal::{{interface.name}}_{{method.name}}_ResponseParams_Data*
      response_params = reinterpret_cast<internal::{{interface.name}}_{{method.name}}_ResponseParams_Data*>(
          response_msg.mutable_payload());
  response_params->DecodePointersAndHandles(response_msg.mutable_handles());
  
  {{struct_macros.deserialize(method.response_param_struct, "response_params",
                              "(*out_%s)")}}
{%-   endif %}
  return true;
}
{%- endfor %}
{%- endfor %}

{%- for namespace in namespaces_as_array|reverse %}
}  // namespace {{namespace}}
{%- endfor %}

#if defined(__clang__)
#pragma clang diagnostic pop
#endif
