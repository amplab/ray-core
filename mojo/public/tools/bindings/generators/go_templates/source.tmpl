// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     {{module.path}}
//

package {{package}}

import (
{% for path, name in imports.iteritems() %}
	{{name}} "{{path}}"
{% endfor %}
)

{% import "enum.tmpl" as enum_macros %}
{% import "interface.tmpl" as interface_macros %}
{% import "struct.tmpl" as struct_macros %}
{% import "union.tmpl" as union_macros %}

{%- if should_gen_mojom_types -%}
// This global variable contains a mojom_types.RuntimeTypeInfo struct
// describing the types defined in this file and all of its imports as
// well as the top-level interfaces defined in this file.
var runtimeTypeInfo__ = {{typepkg}}RuntimeTypeInfo{}

func getRuntimeTypeInfo() {{typepkg}}RuntimeTypeInfo {
  if runtimeTypeInfo__.TypeMap == nil {
    initRuntimeTypeInfo()
  }
  return runtimeTypeInfo__
}

func initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this file.
  // The string contains the base64 encoding of the gzip-compressed bytes.
  serializedRuntimeTypeInfo := "{{module.serialized_runtime_type_info}}"

  // Deserialize RuntimeTypeInfo
  compressedBytes, err := base64.StdEncoding.DecodeString(serializedRuntimeTypeInfo)
  if err != nil {
    panic(fmt.Sprintf("Error while base64Decoding runtimeTypeInfo: %s", err.Error()))
  }
  reader, err := gzip.NewReader(bytes.NewBuffer(compressedBytes))
  if err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  uncompressedBytes, err := ioutil.ReadAll(reader)
  if err != nil {
     panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  if err = reader.Close(); err != nil {
    panic(fmt.Sprintf("Error while decompressing runtimeTypeInfo: %s", err.Error()))
  }
  decoder := bindings.NewDecoder(uncompressedBytes, nil)
  runtimeTypeInfo__.Decode(decoder)

  {% for mi in mojom_imports.values() %}
  {%- if mi ~ '.' != typepkg and mi ~ '.' != descpkg %}
  for s, udt := range {{mi}}.GetAllMojomTypeDefinitions() {
    runtimeTypeInfo__.TypeMap[s] = udt
  }


  {% endif -%}
  {% endfor %}
}
func GetAllMojomTypeDefinitions() map[string]{{typepkg}}UserDefinedType {
  return getRuntimeTypeInfo().TypeMap
}
{% endif %}

{# Enum definitions #}
{%- for enum in enums %}
{{enum_macros.define(enum, typepkg, package)}}
{%- endfor %}

{#- Interface definitions #}
{% for interface in interfaces %}
{{interface_macros.define(interface, descpkg, typepkg, package)}}
{%- endfor %}

{#- Struct definitions #}
{% for struct in structs %}
{{struct_macros.define(struct, typepkg, package)}}
{%- endfor %}

{#- Union definitions #}
{% for union in unions %}
{{union_macros.define(union, typepkg, package)}}
{%- endfor %}
