// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library serialization_test_structs_mojom;
import 'dart:collection';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/mojom_types.mojom.dart' as mojom_types;




class Struct1 extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int i = 0;

  Struct1() : super(kVersions.last.size);

  Struct1.init(
    int this.i
  ) : super(kVersions.last.size);

  static Struct1 deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Struct1 decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Struct1 result = new Struct1();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.i = decoder0.decodeUint8(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Struct1";
    String fieldName;
    try {
      fieldName = "i";
      encoder0.encodeUint8(i, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Struct1("
           "i: $i" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["i"] = i;
    return map;
  }
}


class Struct2 extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  core.MojoHandle hdl = null;

  Struct2() : super(kVersions.last.size);

  Struct2.init(
    core.MojoHandle this.hdl
  ) : super(kVersions.last.size);

  static Struct2 deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Struct2 decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Struct2 result = new Struct2();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.hdl = decoder0.decodeHandle(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Struct2";
    String fieldName;
    try {
      fieldName = "hdl";
      encoder0.encodeHandle(hdl, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Struct2("
           "hdl: $hdl" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class Struct3 extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Struct1 struct1 = null;

  Struct3() : super(kVersions.last.size);

  Struct3.init(
    Struct1 this.struct1
  ) : super(kVersions.last.size);

  static Struct3 deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Struct3 decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Struct3 result = new Struct3();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.struct1 = Struct1.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Struct3";
    String fieldName;
    try {
      fieldName = "struct1";
      encoder0.encodeStruct(struct1, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Struct3("
           "struct1: $struct1" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["struct1"] = struct1;
    return map;
  }
}


class Struct4 extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<Struct1> data = null;

  Struct4() : super(kVersions.last.size);

  Struct4.init(
    List<Struct1> this.data
  ) : super(kVersions.last.size);

  static Struct4 deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Struct4 decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Struct4 result = new Struct4();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.data = new List<Struct1>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.data[i1] = Struct1.decode(decoder2);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Struct4";
    String fieldName;
    try {
      fieldName = "data";
      if (data == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(data.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < data.length; ++i0) {
          encoder1.encodeStruct(data[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Struct4("
           "data: $data" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["data"] = data;
    return map;
  }
}


class Struct5 extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<Struct1> pair = null;

  Struct5() : super(kVersions.last.size);

  Struct5.init(
    List<Struct1> this.pair
  ) : super(kVersions.last.size);

  static Struct5 deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Struct5 decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Struct5 result = new Struct5();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(2);
        result.pair = new List<Struct1>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.pair[i1] = Struct1.decode(decoder2);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Struct5";
    String fieldName;
    try {
      fieldName = "pair";
      if (pair == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(pair.length, 8, 2);
        for (int i0 = 0; i0 < pair.length; ++i0) {
          encoder1.encodeStruct(pair[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Struct5("
           "pair: $pair" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["pair"] = pair;
    return map;
  }
}


class Struct6 extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String str = null;

  Struct6() : super(kVersions.last.size);

  Struct6.init(
    String this.str
  ) : super(kVersions.last.size);

  static Struct6 deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Struct6 decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Struct6 result = new Struct6();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.str = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Struct6";
    String fieldName;
    try {
      fieldName = "str";
      encoder0.encodeString(str, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Struct6("
           "str: $str" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["str"] = str;
    return map;
  }
}


class StructOfNullables extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  core.MojoHandle hdl = null;
  Struct1 struct1 = null;
  String str = null;

  StructOfNullables() : super(kVersions.last.size);

  StructOfNullables.init(
    core.MojoHandle this.hdl, 
    Struct1 this.struct1, 
    String this.str
  ) : super(kVersions.last.size);

  static StructOfNullables deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructOfNullables decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructOfNullables result = new StructOfNullables();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.hdl = decoder0.decodeHandle(8, true);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.struct1 = Struct1.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.str = decoder0.decodeString(24, true);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructOfNullables";
    String fieldName;
    try {
      fieldName = "hdl";
      encoder0.encodeHandle(hdl, 8, true);
      fieldName = "struct1";
      encoder0.encodeStruct(struct1, 16, true);
      fieldName = "str";
      encoder0.encodeString(str, 24, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructOfNullables("
           "hdl: $hdl" ", "
           "struct1: $struct1" ", "
           "str: $str" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


mojom_types.RuntimeTypeInfo getRuntimeTypeInfo() => _runtimeTypeInfo ??
    _initRuntimeTypeInfo();

Map<String, mojom_types.UserDefinedType> getAllMojomTypeDefinitions() {
  return getRuntimeTypeInfo().typeMap;
}

var _runtimeTypeInfo;
mojom_types.RuntimeTypeInfo  _initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this
  // file. The string contains the base64 encoding of the gzip-compressed bytes.
  var serializedRuntimeTypeInfo = "H4sIAAAJbogC/+yYzW7TQBDHY5cobmlFkEBK+ZBCy6EHlKX5UsQpl0qRkAAJDvQUNo6bLGziyutIqE/BkcfgyCNw5Mgj8AjcYDcZw3rZjUxCYge60mi8ztgZ/+eX2XVKudkogn8IXj0feUfxatzQmvk2twK3Fpx/Cf4t+PfgP4L/Av4b+ANut7i9OH120n18cvpo5L/2K6HHwsrzMJi44XHCuGrCuFrCuHrCuEbCuOYs7gG3+/Pinp49mVCKe9RjkY4F0F1IPpTqIOaf7fi8k4/PHSc+/7oTn3/ai8/bUOCyWneod8v+VXd5RDxFHHyH0cnpxzV4rqjI+/z4OjdD+X/jz4HrhUhvuKEJCxD1XUzRwPcH1ENDf+ShiwAjccsqYoE7PULnkx4lLiLj0AvOsOsx1CPjPhkPGBLfyxDzAoIpucAh8cddca7LprmwirjBKK5vLq5HS8mzkEs2THrmJD2FPzJcvw35EINe25BrVvQqSblbUp4m7jor4a5q5K5q0HF3A7i7Ij631sPdVW5boi/1qVavPWAvTb3ksSyH71bCYc3IYW3OOp11DvNr5LAY9bdppt1jVS+h7U6KepU1+cp1VdfDpPuiZXn+sBKe60ae6waeb2wAz/Yaed6FPt7HIdbpdRP0zQLP4ll+/t4V3v4P3htG3hsG3kuXvGt5P8ck0Om1Dz0iC7zb8vqWcd5Xs29uGnlvGni/swG8Wynsm3mmWr3u/iP75iPQs5Sfr1tH4fCVQbeIO+2fJXwccrut4VKNVPUup8xnGXiI8mob1qusvufdS3l/XZRYXOR9xFlAL2uJ95ED0DTt9cz6y+vVn/bV4gK620v01cOMcTqvr25JdfoRAAD//xj2NYbAFwAA";

  // Deserialize RuntimeTypeInfo
  var bytes = BASE64.decode(serializedRuntimeTypeInfo);
  var unzippedBytes = new ZLibDecoder().convert(bytes);
  var bdata = new ByteData.view(unzippedBytes.buffer);
  var message = new bindings.Message(bdata, null, unzippedBytes.length, 0);
  _runtimeTypeInfo = mojom_types.RuntimeTypeInfo.deserialize(message);
  return _runtimeTypeInfo;
}
