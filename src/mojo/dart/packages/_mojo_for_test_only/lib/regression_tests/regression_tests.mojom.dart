// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library regression_tests_mojom;
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/mojom_types.mojom.dart' as mojom_types;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;

class EnumWithReference extends bindings.MojoEnum {
  static const EnumWithReference kStereoAndKeyboardMic = const EnumWithReference._(30);
  static const EnumWithReference kMax = const EnumWithReference._(30);

  const EnumWithReference._(int v) : super(v);

  static const Map<String, EnumWithReference> valuesMap = const {
    "kStereoAndKeyboardMic": kStereoAndKeyboardMic,
    "kMax": kMax,
  };
  static const List<EnumWithReference> values = const [
    kStereoAndKeyboardMic,
    kMax,
  ];

  static EnumWithReference valueOf(String name) => valuesMap[name];

  factory EnumWithReference(int v) {
    switch (v) {
      case 30:
        return EnumWithReference.kStereoAndKeyboardMic;
      case 30:
        return EnumWithReference.kMax;
      default:
        return null;
    }
  }

  static EnumWithReference decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithReference result = new EnumWithReference(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithReference.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case kStereoAndKeyboardMic:
        return 'EnumWithReference.kStereoAndKeyboardMic';
      case kMax:
        return 'EnumWithReference.kMax';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithLowercase extends bindings.MojoEnum {
  static const EnumWithLowercase planarF16 = const EnumWithLowercase._(0);
  static const EnumWithLowercase planarF32 = const EnumWithLowercase._(1);

  const EnumWithLowercase._(int v) : super(v);

  static const Map<String, EnumWithLowercase> valuesMap = const {
    "planarF16": planarF16,
    "planarF32": planarF32,
  };
  static const List<EnumWithLowercase> values = const [
    planarF16,
    planarF32,
  ];

  static EnumWithLowercase valueOf(String name) => valuesMap[name];

  factory EnumWithLowercase(int v) {
    switch (v) {
      case 0:
        return EnumWithLowercase.planarF16;
      case 1:
        return EnumWithLowercase.planarF32;
      default:
        return null;
    }
  }

  static EnumWithLowercase decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithLowercase result = new EnumWithLowercase(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithLowercase.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case planarF16:
        return 'EnumWithLowercase.planarF16';
      case planarF32:
        return 'EnumWithLowercase.planarF32';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithNumbers extends bindings.MojoEnum {
  static const EnumWithNumbers k21 = const EnumWithNumbers._(4);

  const EnumWithNumbers._(int v) : super(v);

  static const Map<String, EnumWithNumbers> valuesMap = const {
    "k21": k21,
  };
  static const List<EnumWithNumbers> values = const [
    k21,
  ];

  static EnumWithNumbers valueOf(String name) => valuesMap[name];

  factory EnumWithNumbers(int v) {
    switch (v) {
      case 4:
        return EnumWithNumbers.k21;
      default:
        return null;
    }
  }

  static EnumWithNumbers decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithNumbers result = new EnumWithNumbers(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithNumbers.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case k21:
        return 'EnumWithNumbers.k21';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithK extends bindings.MojoEnum {
  static const EnumWithK k = const EnumWithK._(0);

  const EnumWithK._(int v) : super(v);

  static const Map<String, EnumWithK> valuesMap = const {
    "k": k,
  };
  static const List<EnumWithK> values = const [
    k,
  ];

  static EnumWithK valueOf(String name) => valuesMap[name];

  factory EnumWithK(int v) {
    switch (v) {
      case 0:
        return EnumWithK.k;
      default:
        return null;
    }
  }

  static EnumWithK decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithK result = new EnumWithK(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithK.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case k:
        return 'EnumWithK.k';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class EnumWithInternalAllCaps extends bindings.MojoEnum {
  static const EnumWithInternalAllCaps standard = const EnumWithInternalAllCaps._(0);
  static const EnumWithInternalAllCaps fullscreen = const EnumWithInternalAllCaps._(1);
  static const EnumWithInternalAllCaps immersive = const EnumWithInternalAllCaps._(2);

  const EnumWithInternalAllCaps._(int v) : super(v);

  static const Map<String, EnumWithInternalAllCaps> valuesMap = const {
    "standard": standard,
    "fullscreen": fullscreen,
    "immersive": immersive,
  };
  static const List<EnumWithInternalAllCaps> values = const [
    standard,
    fullscreen,
    immersive,
  ];

  static EnumWithInternalAllCaps valueOf(String name) => valuesMap[name];

  factory EnumWithInternalAllCaps(int v) {
    switch (v) {
      case 0:
        return EnumWithInternalAllCaps.standard;
      case 1:
        return EnumWithInternalAllCaps.fullscreen;
      case 2:
        return EnumWithInternalAllCaps.immersive;
      default:
        return null;
    }
  }

  static EnumWithInternalAllCaps decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    EnumWithInternalAllCaps result = new EnumWithInternalAllCaps(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum EnumWithInternalAllCaps.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case standard:
        return 'EnumWithInternalAllCaps.standard';
      case fullscreen:
        return 'EnumWithInternalAllCaps.fullscreen';
      case immersive:
        return 'EnumWithInternalAllCaps.immersive';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class NormalEnum extends bindings.MojoEnum {
  static const NormalEnum first = const NormalEnum._(0);
  static const NormalEnum second = const NormalEnum._(1);

  const NormalEnum._(int v) : super(v);

  static const Map<String, NormalEnum> valuesMap = const {
    "first": first,
    "second": second,
  };
  static const List<NormalEnum> values = const [
    first,
    second,
  ];

  static NormalEnum valueOf(String name) => valuesMap[name];

  factory NormalEnum(int v) {
    switch (v) {
      case 0:
        return NormalEnum.first;
      case 1:
        return NormalEnum.second;
      default:
        return null;
    }
  }

  static NormalEnum decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    NormalEnum result = new NormalEnum(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum NormalEnum.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case first:
        return 'NormalEnum.first';
      case second:
        return 'NormalEnum.second';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class CamelCaseTestEnum extends bindings.MojoEnum {
  static const CamelCaseTestEnum boolThing = const CamelCaseTestEnum._(0);
  static const CamelCaseTestEnum doubleThing = const CamelCaseTestEnum._(1);
  static const CamelCaseTestEnum floatThing = const CamelCaseTestEnum._(2);
  static const CamelCaseTestEnum int8Thing = const CamelCaseTestEnum._(3);
  static const CamelCaseTestEnum int16Thing = const CamelCaseTestEnum._(4);
  static const CamelCaseTestEnum int32Th1Ng = const CamelCaseTestEnum._(5);
  static const CamelCaseTestEnum int64Th1ng = const CamelCaseTestEnum._(6);
  static const CamelCaseTestEnum uint8TH1ng = const CamelCaseTestEnum._(7);
  static const CamelCaseTestEnum uint16tH1Ng = const CamelCaseTestEnum._(8);
  static const CamelCaseTestEnum uint32Th1ng = const CamelCaseTestEnum._(9);
  static const CamelCaseTestEnum uint64Th1Ng = const CamelCaseTestEnum._(10);

  const CamelCaseTestEnum._(int v) : super(v);

  static const Map<String, CamelCaseTestEnum> valuesMap = const {
    "boolThing": boolThing,
    "doubleThing": doubleThing,
    "floatThing": floatThing,
    "int8Thing": int8Thing,
    "int16Thing": int16Thing,
    "int32Th1Ng": int32Th1Ng,
    "int64Th1ng": int64Th1ng,
    "uint8TH1ng": uint8TH1ng,
    "uint16tH1Ng": uint16tH1Ng,
    "uint32Th1ng": uint32Th1ng,
    "uint64Th1Ng": uint64Th1Ng,
  };
  static const List<CamelCaseTestEnum> values = const [
    boolThing,
    doubleThing,
    floatThing,
    int8Thing,
    int16Thing,
    int32Th1Ng,
    int64Th1ng,
    uint8TH1ng,
    uint16tH1Ng,
    uint32Th1ng,
    uint64Th1Ng,
  ];

  static CamelCaseTestEnum valueOf(String name) => valuesMap[name];

  factory CamelCaseTestEnum(int v) {
    switch (v) {
      case 0:
        return CamelCaseTestEnum.boolThing;
      case 1:
        return CamelCaseTestEnum.doubleThing;
      case 2:
        return CamelCaseTestEnum.floatThing;
      case 3:
        return CamelCaseTestEnum.int8Thing;
      case 4:
        return CamelCaseTestEnum.int16Thing;
      case 5:
        return CamelCaseTestEnum.int32Th1Ng;
      case 6:
        return CamelCaseTestEnum.int64Th1ng;
      case 7:
        return CamelCaseTestEnum.uint8TH1ng;
      case 8:
        return CamelCaseTestEnum.uint16tH1Ng;
      case 9:
        return CamelCaseTestEnum.uint32Th1ng;
      case 10:
        return CamelCaseTestEnum.uint64Th1Ng;
      default:
        return null;
    }
  }

  static CamelCaseTestEnum decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    CamelCaseTestEnum result = new CamelCaseTestEnum(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum CamelCaseTestEnum.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case boolThing:
        return 'CamelCaseTestEnum.boolThing';
      case doubleThing:
        return 'CamelCaseTestEnum.doubleThing';
      case floatThing:
        return 'CamelCaseTestEnum.floatThing';
      case int8Thing:
        return 'CamelCaseTestEnum.int8Thing';
      case int16Thing:
        return 'CamelCaseTestEnum.int16Thing';
      case int32Th1Ng:
        return 'CamelCaseTestEnum.int32Th1Ng';
      case int64Th1ng:
        return 'CamelCaseTestEnum.int64Th1ng';
      case uint8TH1ng:
        return 'CamelCaseTestEnum.uint8TH1ng';
      case uint16tH1Ng:
        return 'CamelCaseTestEnum.uint16tH1Ng';
      case uint32Th1ng:
        return 'CamelCaseTestEnum.uint32Th1ng';
      case uint64Th1Ng:
        return 'CamelCaseTestEnum.uint64Th1Ng';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}



class Edge extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Vertex v = null;

  Edge() : super(kVersions.last.size);

  Edge.init(
    Vertex this.v
  ) : super(kVersions.last.size);

  static Edge deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Edge decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Edge result = new Edge();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.v = Vertex.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Edge";
    String fieldName;
    try {
      fieldName = "v";
      encoder0.encodeStruct(v, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Edge("
           "v: $v" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["v"] = v;
    return map;
  }
}


class Vertex extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EmptyStruct e = null;

  Vertex() : super(kVersions.last.size);

  Vertex.init(
    EmptyStruct this.e
  ) : super(kVersions.last.size);

  static Vertex deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Vertex decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Vertex result = new Vertex();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.e = EmptyStruct.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Vertex";
    String fieldName;
    try {
      fieldName = "e";
      encoder0.encodeStruct(e, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Vertex("
           "e: $e" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["e"] = e;
    return map;
  }
}


class EmptyStruct extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  EmptyStruct() : super(kVersions.last.size);

  EmptyStruct.init(
  ) : super(kVersions.last.size);

  static EmptyStruct deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static EmptyStruct decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    EmptyStruct result = new EmptyStruct();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "EmptyStruct";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "EmptyStruct("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class A extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  B b = null;

  A() : super(kVersions.last.size);

  A.init(
    B this.b
  ) : super(kVersions.last.size);

  static A deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static A decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    A result = new A();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.b = B.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "A";
    String fieldName;
    try {
      fieldName = "b";
      encoder0.encodeStruct(b, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "A("
           "b: $b" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["b"] = b;
    return map;
  }
}


class B extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  A a = null;

  B() : super(kVersions.last.size);

  B.init(
    A this.a
  ) : super(kVersions.last.size);

  static B deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static B decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    B result = new B();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.a = A.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "B";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeStruct(a, 8, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "B("
           "a: $a" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    return map;
  }
}


class StructWithHandleCalledHandles extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  core.MojoHandle handles = null;

  StructWithHandleCalledHandles() : super(kVersions.last.size);

  StructWithHandleCalledHandles.init(
    core.MojoHandle this.handles
  ) : super(kVersions.last.size);

  static StructWithHandleCalledHandles deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithHandleCalledHandles decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithHandleCalledHandles result = new StructWithHandleCalledHandles();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handles = decoder0.decodeHandle(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithHandleCalledHandles";
    String fieldName;
    try {
      fieldName = "handles";
      encoder0.encodeHandle(handles, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithHandleCalledHandles("
           "handles: $handles" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithArrayOfHandlesCalledHandles extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<core.MojoHandle> handles = null;

  StructWithArrayOfHandlesCalledHandles() : super(kVersions.last.size);

  StructWithArrayOfHandlesCalledHandles.init(
    List<core.MojoHandle> this.handles
  ) : super(kVersions.last.size);

  static StructWithArrayOfHandlesCalledHandles deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithArrayOfHandlesCalledHandles decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithArrayOfHandlesCalledHandles result = new StructWithArrayOfHandlesCalledHandles();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handles = decoder0.decodeHandleArray(8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithArrayOfHandlesCalledHandles";
    String fieldName;
    try {
      fieldName = "handles";
      encoder0.encodeHandleArray(handles, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithArrayOfHandlesCalledHandles("
           "handles: $handles" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class StructWithInterfaceCalledHandles extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  TestInterfaceInterface handles = null;

  StructWithInterfaceCalledHandles() : super(kVersions.last.size);

  StructWithInterfaceCalledHandles.init(
    TestInterfaceInterface this.handles
  ) : super(kVersions.last.size);

  static StructWithInterfaceCalledHandles deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithInterfaceCalledHandles decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithInterfaceCalledHandles result = new StructWithInterfaceCalledHandles();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.handles = decoder0.decodeServiceInterface(8, false, TestInterfaceProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithInterfaceCalledHandles";
    String fieldName;
    try {
      fieldName = "handles";
      encoder0.encodeInterface(handles, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithInterfaceCalledHandles("
           "handles: $handles" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class ContainsArrayOfEnum extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<NormalEnum> arrayOfEnums = null;

  ContainsArrayOfEnum() : super(kVersions.last.size);

  ContainsArrayOfEnum.init(
    List<NormalEnum> this.arrayOfEnums
  ) : super(kVersions.last.size);

  static ContainsArrayOfEnum deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ContainsArrayOfEnum decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ContainsArrayOfEnum result = new ContainsArrayOfEnum();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForEnumArray(bindings.kUnspecifiedArrayLength);
        result.arrayOfEnums = new List<NormalEnum>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
            result.arrayOfEnums[i1] = NormalEnum.decode(decoder1, bindings.ArrayDataHeader.kHeaderSize + bindings.kEnumSize * i1);
            if (result.arrayOfEnums[i1] == null) {
              throw new bindings.MojoCodecError(
                'Trying to decode null union for non-nullable NormalEnum.');
            }
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ContainsArrayOfEnum";
    String fieldName;
    try {
      fieldName = "arrayOfEnums";
      encoder0.encodeEnumArray(arrayOfEnums, 8, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ContainsArrayOfEnum("
           "arrayOfEnums: $arrayOfEnums" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["arrayOfEnums"] = arrayOfEnums;
    return map;
  }
}


class _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams() : super(kVersions.last.size);

  _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams.init(
  ) : super(kVersions.last.size);

  static _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams result = new _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams() : super(kVersions.last.size);

  CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams.init(
  ) : super(kVersions.last.size);

  static CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams result = new CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool b = false;

  _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams() : super(kVersions.last.size);

  _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams.init(
    bool this.b
  ) : super(kVersions.last.size);

  static _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams result = new _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.b = decoder0.decodeBool(8, 0);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams";
    String fieldName;
    try {
      fieldName = "b";
      encoder0.encodeBool(b, 8, 0);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams("
           "b: $b" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["b"] = b;
    return map;
  }
}


class CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams() : super(kVersions.last.size);

  CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams.init(
  ) : super(kVersions.last.size);

  static CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams result = new CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _CheckNameCollisionWithNameCollisionParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool message = false;
  bool response = false;

  _CheckNameCollisionWithNameCollisionParams() : super(kVersions.last.size);

  _CheckNameCollisionWithNameCollisionParams.init(
    bool this.message, 
    bool this.response
  ) : super(kVersions.last.size);

  static _CheckNameCollisionWithNameCollisionParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckNameCollisionWithNameCollisionParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckNameCollisionWithNameCollisionParams result = new _CheckNameCollisionWithNameCollisionParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.message = decoder0.decodeBool(8, 0);
    }
    if (mainDataHeader.version >= 0) {
      
      result.response = decoder0.decodeBool(8, 1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckNameCollisionWithNameCollisionParams";
    String fieldName;
    try {
      fieldName = "message";
      encoder0.encodeBool(message, 8, 0);
      fieldName = "response";
      encoder0.encodeBool(response, 8, 1);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckNameCollisionWithNameCollisionParams("
           "message: $message" ", "
           "response: $response" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["message"] = message;
    map["response"] = response;
    return map;
  }
}


class CheckNameCollisionWithNameCollisionResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  bool message = false;
  bool response = false;

  CheckNameCollisionWithNameCollisionResponseParams() : super(kVersions.last.size);

  CheckNameCollisionWithNameCollisionResponseParams.init(
    bool this.message, 
    bool this.response
  ) : super(kVersions.last.size);

  static CheckNameCollisionWithNameCollisionResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static CheckNameCollisionWithNameCollisionResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    CheckNameCollisionWithNameCollisionResponseParams result = new CheckNameCollisionWithNameCollisionResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.message = decoder0.decodeBool(8, 0);
    }
    if (mainDataHeader.version >= 0) {
      
      result.response = decoder0.decodeBool(8, 1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "CheckNameCollisionWithNameCollisionResponseParams";
    String fieldName;
    try {
      fieldName = "message";
      encoder0.encodeBool(message, 8, 0);
      fieldName = "response";
      encoder0.encodeBool(response, 8, 1);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "CheckNameCollisionWithNameCollisionResponseParams("
           "message: $message" ", "
           "response: $response" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["message"] = message;
    map["response"] = response;
    return map;
  }
}


class _CheckEnumCapsSetEnumWithInternalAllCapsParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  EnumWithInternalAllCaps e = null;

  _CheckEnumCapsSetEnumWithInternalAllCapsParams() : super(kVersions.last.size);

  _CheckEnumCapsSetEnumWithInternalAllCapsParams.init(
    EnumWithInternalAllCaps this.e
  ) : super(kVersions.last.size);

  static _CheckEnumCapsSetEnumWithInternalAllCapsParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _CheckEnumCapsSetEnumWithInternalAllCapsParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _CheckEnumCapsSetEnumWithInternalAllCapsParams result = new _CheckEnumCapsSetEnumWithInternalAllCapsParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.e = EnumWithInternalAllCaps.decode(decoder0, 8);
        if (result.e == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable EnumWithInternalAllCaps.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_CheckEnumCapsSetEnumWithInternalAllCapsParams";
    String fieldName;
    try {
      fieldName = "e";
      encoder0.encodeEnum(e, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_CheckEnumCapsSetEnumWithInternalAllCapsParams("
           "e: $e" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["e"] = e;
    return map;
  }
}


class _TestInterfaceSomeMessageParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _TestInterfaceSomeMessageParams() : super(kVersions.last.size);

  _TestInterfaceSomeMessageParams.init(
  ) : super(kVersions.last.size);

  static _TestInterfaceSomeMessageParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _TestInterfaceSomeMessageParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _TestInterfaceSomeMessageParams result = new _TestInterfaceSomeMessageParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_TestInterfaceSomeMessageParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_TestInterfaceSomeMessageParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _Regression551GetParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  List<String> keyPrefixes = null;

  _Regression551GetParams() : super(kVersions.last.size);

  _Regression551GetParams.init(
    List<String> this.keyPrefixes
  ) : super(kVersions.last.size);

  static _Regression551GetParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _Regression551GetParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _Regression551GetParams result = new _Regression551GetParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.keyPrefixes = new List<String>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.keyPrefixes[i1] = decoder1.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
        }
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_Regression551GetParams";
    String fieldName;
    try {
      fieldName = "keyPrefixes";
      if (keyPrefixes == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encodePointerArray(keyPrefixes.length, 8, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < keyPrefixes.length; ++i0) {
          encoder1.encodeString(keyPrefixes[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_Regression551GetParams("
           "keyPrefixes: $keyPrefixes" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["keyPrefixes"] = keyPrefixes;
    return map;
  }
}


class Regression551GetResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int result = 0;

  Regression551GetResponseParams() : super(kVersions.last.size);

  Regression551GetResponseParams.init(
    int this.result
  ) : super(kVersions.last.size);

  static Regression551GetResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Regression551GetResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Regression551GetResponseParams result = new Regression551GetResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.result = decoder0.decodeInt32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Regression551GetResponseParams";
    String fieldName;
    try {
      fieldName = "result";
      encoder0.encodeInt32(result, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Regression551GetResponseParams("
           "result: $result" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["result"] = result;
    return map;
  }
}


class _ServiceNameServiceNameParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _ServiceNameServiceNameParams() : super(kVersions.last.size);

  _ServiceNameServiceNameParams.init(
  ) : super(kVersions.last.size);

  static _ServiceNameServiceNameParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ServiceNameServiceNameParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ServiceNameServiceNameParams result = new _ServiceNameServiceNameParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ServiceNameServiceNameParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ServiceNameServiceNameParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class ServiceNameServiceNameResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String serviceName_ = null;

  ServiceNameServiceNameResponseParams() : super(kVersions.last.size);

  ServiceNameServiceNameResponseParams.init(
    String this.serviceName_
  ) : super(kVersions.last.size);

  static ServiceNameServiceNameResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ServiceNameServiceNameResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ServiceNameServiceNameResponseParams result = new ServiceNameServiceNameResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.serviceName_ = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ServiceNameServiceNameResponseParams";
    String fieldName;
    try {
      fieldName = "serviceName_";
      encoder0.encodeString(serviceName_, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ServiceNameServiceNameResponseParams("
           "serviceName_: $serviceName_" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["serviceName_"] = serviceName_;
    return map;
  }
}

const int _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName = 0;
const int _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName = 1;

class _CheckMethodWithEmptyResponseServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CheckMethodWithEmptyResponse {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CheckMethodWithEmptyResponseServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CheckMethodWithEmptyResponseProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CheckMethodWithEmptyResponseProxy p = new CheckMethodWithEmptyResponseProxy.unbound();
    String name = serviceName ?? CheckMethodWithEmptyResponse.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void withoutParameterAndEmptyResponse(void callback());
  void withParameterAndEmptyResponse(bool b,void callback());
}

abstract class CheckMethodWithEmptyResponseInterface
    implements bindings.MojoInterface<CheckMethodWithEmptyResponse>,
               CheckMethodWithEmptyResponse {
  factory CheckMethodWithEmptyResponseInterface([CheckMethodWithEmptyResponse impl]) =>
      new CheckMethodWithEmptyResponseStub.unbound(impl);

  factory CheckMethodWithEmptyResponseInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CheckMethodWithEmptyResponse impl]) =>
      new CheckMethodWithEmptyResponseStub.fromEndpoint(endpoint, impl);

  factory CheckMethodWithEmptyResponseInterface.fromMock(
      CheckMethodWithEmptyResponse mock) =>
      new CheckMethodWithEmptyResponseProxy.fromMock(mock);
}

abstract class CheckMethodWithEmptyResponseInterfaceRequest
    implements bindings.MojoInterface<CheckMethodWithEmptyResponse>,
               CheckMethodWithEmptyResponse {
  factory CheckMethodWithEmptyResponseInterfaceRequest() =>
      new CheckMethodWithEmptyResponseProxy.unbound();
}

class _CheckMethodWithEmptyResponseProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CheckMethodWithEmptyResponse> {
  CheckMethodWithEmptyResponse impl;

  _CheckMethodWithEmptyResponseProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CheckMethodWithEmptyResponseProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CheckMethodWithEmptyResponseProxyControl.unbound() : super.unbound();

  String get serviceName => CheckMethodWithEmptyResponse.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName:
        var r = CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback();
        break;
      case _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName:
        var r = CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback();
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckMethodWithEmptyResponseProxyControl($superString)";
  }
}

class CheckMethodWithEmptyResponseProxy
    extends bindings.Proxy<CheckMethodWithEmptyResponse>
    implements CheckMethodWithEmptyResponse,
               CheckMethodWithEmptyResponseInterface,
               CheckMethodWithEmptyResponseInterfaceRequest {
  CheckMethodWithEmptyResponseProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CheckMethodWithEmptyResponseProxyControl.fromEndpoint(endpoint));

  CheckMethodWithEmptyResponseProxy.fromHandle(core.MojoHandle handle)
      : super(new _CheckMethodWithEmptyResponseProxyControl.fromHandle(handle));

  CheckMethodWithEmptyResponseProxy.unbound()
      : super(new _CheckMethodWithEmptyResponseProxyControl.unbound());

  factory CheckMethodWithEmptyResponseProxy.fromMock(CheckMethodWithEmptyResponse mock) {
    CheckMethodWithEmptyResponseProxy newMockedProxy =
        new CheckMethodWithEmptyResponseProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CheckMethodWithEmptyResponseProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckMethodWithEmptyResponseProxy"));
    return new CheckMethodWithEmptyResponseProxy.fromEndpoint(endpoint);
  }


  void withoutParameterAndEmptyResponse(void callback()) {
    if (impl != null) {
      impl.withoutParameterAndEmptyResponse(callback);
      return;
    }
    var params = new _CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void withParameterAndEmptyResponse(bool b,void callback()) {
    if (impl != null) {
      impl.withParameterAndEmptyResponse(b,callback);
      return;
    }
    var params = new _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams();
    params.b = b;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = (() {
        z.bindCallback(() {
          callback();
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _CheckMethodWithEmptyResponseStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CheckMethodWithEmptyResponse> {
  CheckMethodWithEmptyResponse _impl;

  _CheckMethodWithEmptyResponseStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckMethodWithEmptyResponse impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckMethodWithEmptyResponseStubControl.fromHandle(
      core.MojoHandle handle, [CheckMethodWithEmptyResponse impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckMethodWithEmptyResponseStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CheckMethodWithEmptyResponse.serviceName;


  Function _checkMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParamsResponder(
      int requestId) {
  return () {
      var result = new CheckMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _checkMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParamsResponder(
      int requestId) {
  return () {
      var result = new CheckMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParams();
      sendResponse(buildResponseWithId(
          result,
          _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _checkMethodWithEmptyResponseMethodWithoutParameterAndEmptyResponseName:
        _impl.withoutParameterAndEmptyResponse(_checkMethodWithEmptyResponseWithoutParameterAndEmptyResponseResponseParamsResponder(message.header.requestId));
        break;
      case _checkMethodWithEmptyResponseMethodWithParameterAndEmptyResponseName:
        var params = _CheckMethodWithEmptyResponseWithParameterAndEmptyResponseParams.deserialize(
            message.payload);
        _impl.withParameterAndEmptyResponse(params.b, _checkMethodWithEmptyResponseWithParameterAndEmptyResponseResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CheckMethodWithEmptyResponse get impl => _impl;
  set impl(CheckMethodWithEmptyResponse d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckMethodWithEmptyResponseStubControl($superString)";
  }

  int get version => 0;
}

class CheckMethodWithEmptyResponseStub
    extends bindings.Stub<CheckMethodWithEmptyResponse>
    implements CheckMethodWithEmptyResponse,
               CheckMethodWithEmptyResponseInterface,
               CheckMethodWithEmptyResponseInterfaceRequest {
  CheckMethodWithEmptyResponseStub.unbound([CheckMethodWithEmptyResponse impl])
      : super(new _CheckMethodWithEmptyResponseStubControl.unbound(impl));

  CheckMethodWithEmptyResponseStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckMethodWithEmptyResponse impl])
      : super(new _CheckMethodWithEmptyResponseStubControl.fromEndpoint(endpoint, impl));

  CheckMethodWithEmptyResponseStub.fromHandle(
      core.MojoHandle handle, [CheckMethodWithEmptyResponse impl])
      : super(new _CheckMethodWithEmptyResponseStubControl.fromHandle(handle, impl));

  static CheckMethodWithEmptyResponseStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckMethodWithEmptyResponseStub"));
    return new CheckMethodWithEmptyResponseStub.fromEndpoint(endpoint);
  }


  void withoutParameterAndEmptyResponse(void callback()) {
    return impl.withoutParameterAndEmptyResponse(callback);
  }
  void withParameterAndEmptyResponse(bool b,void callback()) {
    return impl.withParameterAndEmptyResponse(b,callback);
  }
}

const int _checkNameCollisionMethodWithNameCollisionName = 0;

class _CheckNameCollisionServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CheckNameCollision {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CheckNameCollisionServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CheckNameCollisionProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CheckNameCollisionProxy p = new CheckNameCollisionProxy.unbound();
    String name = serviceName ?? CheckNameCollision.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void withNameCollision(bool message,bool response,void callback(bool message, bool response));
}

abstract class CheckNameCollisionInterface
    implements bindings.MojoInterface<CheckNameCollision>,
               CheckNameCollision {
  factory CheckNameCollisionInterface([CheckNameCollision impl]) =>
      new CheckNameCollisionStub.unbound(impl);

  factory CheckNameCollisionInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CheckNameCollision impl]) =>
      new CheckNameCollisionStub.fromEndpoint(endpoint, impl);

  factory CheckNameCollisionInterface.fromMock(
      CheckNameCollision mock) =>
      new CheckNameCollisionProxy.fromMock(mock);
}

abstract class CheckNameCollisionInterfaceRequest
    implements bindings.MojoInterface<CheckNameCollision>,
               CheckNameCollision {
  factory CheckNameCollisionInterfaceRequest() =>
      new CheckNameCollisionProxy.unbound();
}

class _CheckNameCollisionProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CheckNameCollision> {
  CheckNameCollision impl;

  _CheckNameCollisionProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CheckNameCollisionProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CheckNameCollisionProxyControl.unbound() : super.unbound();

  String get serviceName => CheckNameCollision.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _checkNameCollisionMethodWithNameCollisionName:
        var r = CheckNameCollisionWithNameCollisionResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.message , r.response );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckNameCollisionProxyControl($superString)";
  }
}

class CheckNameCollisionProxy
    extends bindings.Proxy<CheckNameCollision>
    implements CheckNameCollision,
               CheckNameCollisionInterface,
               CheckNameCollisionInterfaceRequest {
  CheckNameCollisionProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CheckNameCollisionProxyControl.fromEndpoint(endpoint));

  CheckNameCollisionProxy.fromHandle(core.MojoHandle handle)
      : super(new _CheckNameCollisionProxyControl.fromHandle(handle));

  CheckNameCollisionProxy.unbound()
      : super(new _CheckNameCollisionProxyControl.unbound());

  factory CheckNameCollisionProxy.fromMock(CheckNameCollision mock) {
    CheckNameCollisionProxy newMockedProxy =
        new CheckNameCollisionProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CheckNameCollisionProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckNameCollisionProxy"));
    return new CheckNameCollisionProxy.fromEndpoint(endpoint);
  }


  void withNameCollision(bool message,bool response,void callback(bool message, bool response)) {
    if (impl != null) {
      impl.withNameCollision(message,response,callback);
      return;
    }
    var params = new _CheckNameCollisionWithNameCollisionParams();
    params.message = message;
    params.response = response;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((bool message, bool response) {
        z.bindCallback(() {
          callback(message, response);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _checkNameCollisionMethodWithNameCollisionName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _CheckNameCollisionStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CheckNameCollision> {
  CheckNameCollision _impl;

  _CheckNameCollisionStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckNameCollision impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckNameCollisionStubControl.fromHandle(
      core.MojoHandle handle, [CheckNameCollision impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckNameCollisionStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CheckNameCollision.serviceName;


  Function _checkNameCollisionWithNameCollisionResponseParamsResponder(
      int requestId) {
  return (bool message, bool response) {
      var result = new CheckNameCollisionWithNameCollisionResponseParams();
      result.message = message;
      result.response = response;
      sendResponse(buildResponseWithId(
          result,
          _checkNameCollisionMethodWithNameCollisionName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _checkNameCollisionMethodWithNameCollisionName:
        var params = _CheckNameCollisionWithNameCollisionParams.deserialize(
            message.payload);
        _impl.withNameCollision(params.message, params.response, _checkNameCollisionWithNameCollisionResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CheckNameCollision get impl => _impl;
  set impl(CheckNameCollision d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckNameCollisionStubControl($superString)";
  }

  int get version => 0;
}

class CheckNameCollisionStub
    extends bindings.Stub<CheckNameCollision>
    implements CheckNameCollision,
               CheckNameCollisionInterface,
               CheckNameCollisionInterfaceRequest {
  CheckNameCollisionStub.unbound([CheckNameCollision impl])
      : super(new _CheckNameCollisionStubControl.unbound(impl));

  CheckNameCollisionStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckNameCollision impl])
      : super(new _CheckNameCollisionStubControl.fromEndpoint(endpoint, impl));

  CheckNameCollisionStub.fromHandle(
      core.MojoHandle handle, [CheckNameCollision impl])
      : super(new _CheckNameCollisionStubControl.fromHandle(handle, impl));

  static CheckNameCollisionStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckNameCollisionStub"));
    return new CheckNameCollisionStub.fromEndpoint(endpoint);
  }


  void withNameCollision(bool message,bool response,void callback(bool message, bool response)) {
    return impl.withNameCollision(message,response,callback);
  }
}

const int _checkEnumCapsMethodSetEnumWithInternalAllCapsName = 0;

class _CheckEnumCapsServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class CheckEnumCaps {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _CheckEnumCapsServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static CheckEnumCapsProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    CheckEnumCapsProxy p = new CheckEnumCapsProxy.unbound();
    String name = serviceName ?? CheckEnumCaps.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void setEnumWithInternalAllCaps(EnumWithInternalAllCaps e);
}

abstract class CheckEnumCapsInterface
    implements bindings.MojoInterface<CheckEnumCaps>,
               CheckEnumCaps {
  factory CheckEnumCapsInterface([CheckEnumCaps impl]) =>
      new CheckEnumCapsStub.unbound(impl);

  factory CheckEnumCapsInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [CheckEnumCaps impl]) =>
      new CheckEnumCapsStub.fromEndpoint(endpoint, impl);

  factory CheckEnumCapsInterface.fromMock(
      CheckEnumCaps mock) =>
      new CheckEnumCapsProxy.fromMock(mock);
}

abstract class CheckEnumCapsInterfaceRequest
    implements bindings.MojoInterface<CheckEnumCaps>,
               CheckEnumCaps {
  factory CheckEnumCapsInterfaceRequest() =>
      new CheckEnumCapsProxy.unbound();
}

class _CheckEnumCapsProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<CheckEnumCaps> {
  CheckEnumCaps impl;

  _CheckEnumCapsProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _CheckEnumCapsProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _CheckEnumCapsProxyControl.unbound() : super.unbound();

  String get serviceName => CheckEnumCaps.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckEnumCapsProxyControl($superString)";
  }
}

class CheckEnumCapsProxy
    extends bindings.Proxy<CheckEnumCaps>
    implements CheckEnumCaps,
               CheckEnumCapsInterface,
               CheckEnumCapsInterfaceRequest {
  CheckEnumCapsProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _CheckEnumCapsProxyControl.fromEndpoint(endpoint));

  CheckEnumCapsProxy.fromHandle(core.MojoHandle handle)
      : super(new _CheckEnumCapsProxyControl.fromHandle(handle));

  CheckEnumCapsProxy.unbound()
      : super(new _CheckEnumCapsProxyControl.unbound());

  factory CheckEnumCapsProxy.fromMock(CheckEnumCaps mock) {
    CheckEnumCapsProxy newMockedProxy =
        new CheckEnumCapsProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static CheckEnumCapsProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckEnumCapsProxy"));
    return new CheckEnumCapsProxy.fromEndpoint(endpoint);
  }


  void setEnumWithInternalAllCaps(EnumWithInternalAllCaps e) {
    if (impl != null) {
      impl.setEnumWithInternalAllCaps(e);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _CheckEnumCapsSetEnumWithInternalAllCapsParams();
    params.e = e;
    ctrl.sendMessage(params,
        _checkEnumCapsMethodSetEnumWithInternalAllCapsName);
  }
}

class _CheckEnumCapsStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<CheckEnumCaps> {
  CheckEnumCaps _impl;

  _CheckEnumCapsStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckEnumCaps impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckEnumCapsStubControl.fromHandle(
      core.MojoHandle handle, [CheckEnumCaps impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _CheckEnumCapsStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => CheckEnumCaps.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _checkEnumCapsMethodSetEnumWithInternalAllCapsName:
        var params = _CheckEnumCapsSetEnumWithInternalAllCapsParams.deserialize(
            message.payload);
        _impl.setEnumWithInternalAllCaps(params.e);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  CheckEnumCaps get impl => _impl;
  set impl(CheckEnumCaps d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_CheckEnumCapsStubControl($superString)";
  }

  int get version => 0;
}

class CheckEnumCapsStub
    extends bindings.Stub<CheckEnumCaps>
    implements CheckEnumCaps,
               CheckEnumCapsInterface,
               CheckEnumCapsInterfaceRequest {
  CheckEnumCapsStub.unbound([CheckEnumCaps impl])
      : super(new _CheckEnumCapsStubControl.unbound(impl));

  CheckEnumCapsStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [CheckEnumCaps impl])
      : super(new _CheckEnumCapsStubControl.fromEndpoint(endpoint, impl));

  CheckEnumCapsStub.fromHandle(
      core.MojoHandle handle, [CheckEnumCaps impl])
      : super(new _CheckEnumCapsStubControl.fromHandle(handle, impl));

  static CheckEnumCapsStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For CheckEnumCapsStub"));
    return new CheckEnumCapsStub.fromEndpoint(endpoint);
  }


  void setEnumWithInternalAllCaps(EnumWithInternalAllCaps e) {
    return impl.setEnumWithInternalAllCaps(e);
  }
}

const int _testInterfaceMethodSomeMessageName = 0;

class _TestInterfaceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class TestInterface {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _TestInterfaceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static TestInterfaceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    TestInterfaceProxy p = new TestInterfaceProxy.unbound();
    String name = serviceName ?? TestInterface.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void someMessage();
}

abstract class TestInterfaceInterface
    implements bindings.MojoInterface<TestInterface>,
               TestInterface {
  factory TestInterfaceInterface([TestInterface impl]) =>
      new TestInterfaceStub.unbound(impl);

  factory TestInterfaceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [TestInterface impl]) =>
      new TestInterfaceStub.fromEndpoint(endpoint, impl);

  factory TestInterfaceInterface.fromMock(
      TestInterface mock) =>
      new TestInterfaceProxy.fromMock(mock);
}

abstract class TestInterfaceInterfaceRequest
    implements bindings.MojoInterface<TestInterface>,
               TestInterface {
  factory TestInterfaceInterfaceRequest() =>
      new TestInterfaceProxy.unbound();
}

class _TestInterfaceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<TestInterface> {
  TestInterface impl;

  _TestInterfaceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _TestInterfaceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _TestInterfaceProxyControl.unbound() : super.unbound();

  String get serviceName => TestInterface.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestInterfaceProxyControl($superString)";
  }
}

class TestInterfaceProxy
    extends bindings.Proxy<TestInterface>
    implements TestInterface,
               TestInterfaceInterface,
               TestInterfaceInterfaceRequest {
  TestInterfaceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _TestInterfaceProxyControl.fromEndpoint(endpoint));

  TestInterfaceProxy.fromHandle(core.MojoHandle handle)
      : super(new _TestInterfaceProxyControl.fromHandle(handle));

  TestInterfaceProxy.unbound()
      : super(new _TestInterfaceProxyControl.unbound());

  factory TestInterfaceProxy.fromMock(TestInterface mock) {
    TestInterfaceProxy newMockedProxy =
        new TestInterfaceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static TestInterfaceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestInterfaceProxy"));
    return new TestInterfaceProxy.fromEndpoint(endpoint);
  }


  void someMessage() {
    if (impl != null) {
      impl.someMessage();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _TestInterfaceSomeMessageParams();
    ctrl.sendMessage(params,
        _testInterfaceMethodSomeMessageName);
  }
}

class _TestInterfaceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<TestInterface> {
  TestInterface _impl;

  _TestInterfaceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestInterface impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestInterfaceStubControl.fromHandle(
      core.MojoHandle handle, [TestInterface impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _TestInterfaceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => TestInterface.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _testInterfaceMethodSomeMessageName:
        _impl.someMessage();
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  TestInterface get impl => _impl;
  set impl(TestInterface d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_TestInterfaceStubControl($superString)";
  }

  int get version => 0;
}

class TestInterfaceStub
    extends bindings.Stub<TestInterface>
    implements TestInterface,
               TestInterfaceInterface,
               TestInterfaceInterfaceRequest {
  TestInterfaceStub.unbound([TestInterface impl])
      : super(new _TestInterfaceStubControl.unbound(impl));

  TestInterfaceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [TestInterface impl])
      : super(new _TestInterfaceStubControl.fromEndpoint(endpoint, impl));

  TestInterfaceStub.fromHandle(
      core.MojoHandle handle, [TestInterface impl])
      : super(new _TestInterfaceStubControl.fromHandle(handle, impl));

  static TestInterfaceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For TestInterfaceStub"));
    return new TestInterfaceStub.fromEndpoint(endpoint);
  }


  void someMessage() {
    return impl.someMessage();
  }
}

const int _regression551MethodGetName = 0;

class _Regression551ServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class Regression551 {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _Regression551ServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static Regression551Proxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    Regression551Proxy p = new Regression551Proxy.unbound();
    String name = serviceName ?? Regression551.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void get(List<String> keyPrefixes,void callback(int result));
}

abstract class Regression551Interface
    implements bindings.MojoInterface<Regression551>,
               Regression551 {
  factory Regression551Interface([Regression551 impl]) =>
      new Regression551Stub.unbound(impl);

  factory Regression551Interface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [Regression551 impl]) =>
      new Regression551Stub.fromEndpoint(endpoint, impl);

  factory Regression551Interface.fromMock(
      Regression551 mock) =>
      new Regression551Proxy.fromMock(mock);
}

abstract class Regression551InterfaceRequest
    implements bindings.MojoInterface<Regression551>,
               Regression551 {
  factory Regression551InterfaceRequest() =>
      new Regression551Proxy.unbound();
}

class _Regression551ProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<Regression551> {
  Regression551 impl;

  _Regression551ProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _Regression551ProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _Regression551ProxyControl.unbound() : super.unbound();

  String get serviceName => Regression551.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _regression551MethodGetName:
        var r = Regression551GetResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.result );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_Regression551ProxyControl($superString)";
  }
}

class Regression551Proxy
    extends bindings.Proxy<Regression551>
    implements Regression551,
               Regression551Interface,
               Regression551InterfaceRequest {
  Regression551Proxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _Regression551ProxyControl.fromEndpoint(endpoint));

  Regression551Proxy.fromHandle(core.MojoHandle handle)
      : super(new _Regression551ProxyControl.fromHandle(handle));

  Regression551Proxy.unbound()
      : super(new _Regression551ProxyControl.unbound());

  factory Regression551Proxy.fromMock(Regression551 mock) {
    Regression551Proxy newMockedProxy =
        new Regression551Proxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static Regression551Proxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For Regression551Proxy"));
    return new Regression551Proxy.fromEndpoint(endpoint);
  }


  void get(List<String> keyPrefixes,void callback(int result)) {
    if (impl != null) {
      impl.get(keyPrefixes,callback);
      return;
    }
    var params = new _Regression551GetParams();
    params.keyPrefixes = keyPrefixes;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((int result) {
        z.bindCallback(() {
          callback(result);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _regression551MethodGetName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _Regression551StubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<Regression551> {
  Regression551 _impl;

  _Regression551StubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Regression551 impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _Regression551StubControl.fromHandle(
      core.MojoHandle handle, [Regression551 impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _Regression551StubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => Regression551.serviceName;


  Function _regression551GetResponseParamsResponder(
      int requestId) {
  return (int result) {
      var result = new Regression551GetResponseParams();
      result.result = result;
      sendResponse(buildResponseWithId(
          result,
          _regression551MethodGetName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _regression551MethodGetName:
        var params = _Regression551GetParams.deserialize(
            message.payload);
        _impl.get(params.keyPrefixes, _regression551GetResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  Regression551 get impl => _impl;
  set impl(Regression551 d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_Regression551StubControl($superString)";
  }

  int get version => 0;
}

class Regression551Stub
    extends bindings.Stub<Regression551>
    implements Regression551,
               Regression551Interface,
               Regression551InterfaceRequest {
  Regression551Stub.unbound([Regression551 impl])
      : super(new _Regression551StubControl.unbound(impl));

  Regression551Stub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Regression551 impl])
      : super(new _Regression551StubControl.fromEndpoint(endpoint, impl));

  Regression551Stub.fromHandle(
      core.MojoHandle handle, [Regression551 impl])
      : super(new _Regression551StubControl.fromHandle(handle, impl));

  static Regression551Stub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For Regression551Stub"));
    return new Regression551Stub.fromEndpoint(endpoint);
  }


  void get(List<String> keyPrefixes,void callback(int result)) {
    return impl.get(keyPrefixes,callback);
  }
}

const int _serviceNameMethodServiceNameName = 0;

class _ServiceNameServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class ServiceName {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _ServiceNameServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static ServiceNameProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    ServiceNameProxy p = new ServiceNameProxy.unbound();
    String name = serviceName ?? ServiceName.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void serviceName_(void callback(String serviceName_));
}

abstract class ServiceNameInterface
    implements bindings.MojoInterface<ServiceName>,
               ServiceName {
  factory ServiceNameInterface([ServiceName impl]) =>
      new ServiceNameStub.unbound(impl);

  factory ServiceNameInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [ServiceName impl]) =>
      new ServiceNameStub.fromEndpoint(endpoint, impl);

  factory ServiceNameInterface.fromMock(
      ServiceName mock) =>
      new ServiceNameProxy.fromMock(mock);
}

abstract class ServiceNameInterfaceRequest
    implements bindings.MojoInterface<ServiceName>,
               ServiceName {
  factory ServiceNameInterfaceRequest() =>
      new ServiceNameProxy.unbound();
}

class _ServiceNameProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<ServiceName> {
  ServiceName impl;

  _ServiceNameProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _ServiceNameProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _ServiceNameProxyControl.unbound() : super.unbound();

  String get serviceName => ServiceName.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _serviceNameMethodServiceNameName:
        var r = ServiceNameServiceNameResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.serviceName_ );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ServiceNameProxyControl($superString)";
  }
}

class ServiceNameProxy
    extends bindings.Proxy<ServiceName>
    implements ServiceName,
               ServiceNameInterface,
               ServiceNameInterfaceRequest {
  ServiceNameProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _ServiceNameProxyControl.fromEndpoint(endpoint));

  ServiceNameProxy.fromHandle(core.MojoHandle handle)
      : super(new _ServiceNameProxyControl.fromHandle(handle));

  ServiceNameProxy.unbound()
      : super(new _ServiceNameProxyControl.unbound());

  factory ServiceNameProxy.fromMock(ServiceName mock) {
    ServiceNameProxy newMockedProxy =
        new ServiceNameProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static ServiceNameProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ServiceNameProxy"));
    return new ServiceNameProxy.fromEndpoint(endpoint);
  }


  void serviceName_(void callback(String serviceName_)) {
    if (impl != null) {
      impl.serviceName_(callback);
      return;
    }
    var params = new _ServiceNameServiceNameParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((String serviceName_) {
        z.bindCallback(() {
          callback(serviceName_);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _serviceNameMethodServiceNameName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _ServiceNameStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<ServiceName> {
  ServiceName _impl;

  _ServiceNameStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ServiceName impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _ServiceNameStubControl.fromHandle(
      core.MojoHandle handle, [ServiceName impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _ServiceNameStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => ServiceName.serviceName;


  Function _serviceNameServiceNameResponseParamsResponder(
      int requestId) {
  return (String serviceName_) {
      var result = new ServiceNameServiceNameResponseParams();
      result.serviceName_ = serviceName_;
      sendResponse(buildResponseWithId(
          result,
          _serviceNameMethodServiceNameName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _serviceNameMethodServiceNameName:
        _impl.serviceName_(_serviceNameServiceNameResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  ServiceName get impl => _impl;
  set impl(ServiceName d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ServiceNameStubControl($superString)";
  }

  int get version => 0;
}

class ServiceNameStub
    extends bindings.Stub<ServiceName>
    implements ServiceName,
               ServiceNameInterface,
               ServiceNameInterfaceRequest {
  ServiceNameStub.unbound([ServiceName impl])
      : super(new _ServiceNameStubControl.unbound(impl));

  ServiceNameStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [ServiceName impl])
      : super(new _ServiceNameStubControl.fromEndpoint(endpoint, impl));

  ServiceNameStub.fromHandle(
      core.MojoHandle handle, [ServiceName impl])
      : super(new _ServiceNameStubControl.fromHandle(handle, impl));

  static ServiceNameStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ServiceNameStub"));
    return new ServiceNameStub.fromEndpoint(endpoint);
  }


  void serviceName_(void callback(String serviceName_)) {
    return impl.serviceName_(callback);
  }
}


mojom_types.RuntimeTypeInfo getRuntimeTypeInfo() => _runtimeTypeInfo ??
    _initRuntimeTypeInfo();

Map<String, mojom_types.UserDefinedType> getAllMojomTypeDefinitions() {
  return getRuntimeTypeInfo().typeMap;
}

var _runtimeTypeInfo;
mojom_types.RuntimeTypeInfo  _initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this
  // file. The string contains the base64 encoding of the gzip-compressed bytes.
  var serializedRuntimeTypeInfo = "H4sIAAAJbogC/+xdzVcbRxLvETgmNknwbpzgkBDibGJvHEuAjaM4uwkCC8QCgifJCXnZfbIsBqSgD3YksnhPOeboY/6EHH30Mcccfdyjj3vco2+73ZpqNF2anumRR1KLRe/1a4/cNer+dX10V1U3k8T+TEA9CzX+ntdjqMbtts/Z9VNa3qLlCXz/DOr/QD1j2HUK6h+hfgL1c6hJxK6uQ/0A6p+gfgr1v6GeHLHrRahLUD+G+hnUY6Pw+1AfQv0hLVO05L7dTubXk9/etcx9y2w0yvVavmk2mo1oQrHdUqvdLVpueLZbLlTNynKhYeboY7J2VG3RxWi55k1XMosHrP1y4bBBvqRt7/i33zSbpfruN+VmKVk9bD7KmI3Deq1hEnKb0n7qT5+mnV2uVypl9h+snwu03PSmq9eahXKtkbCswqOtPRjhx7RMe9Ild/dN+90febdjA8k2raNik7b7nJY57/a0AwyAtXQumUknNhKVSgtB+3MD5taffl1xfnn7jfo/TKtYYGBDH/+oRJc+qj40Ld4/9d/LmHumZdaK9u+xuf2DJ126blULFc6A/vyXOfliYWFOYZ6ypvVDuWgyDqLtVmn5yrt9a0rZSIBzUoXabsVsLBcqFXMXHlrv+EzxPTaNSM+k9K4i/VqtaVp7hSJ6haK8MvE+eQO5znSgZ/uvTatpHpcMW48y/cpU4o7R1reGQ49x/fv0lfYzU3UvLovP21Pic+oj8X2/RsXn3+bE5+Pb4u/9uiA+P7srPl//s/j8fFF8XlwWn39eFfs3s476nxH7s7MjPs98Jz4//ZtI/+SB+P+pXbBHyJ6NcbsEdgW6ffLhdjIO9X/hkyLun1fh9xLw/A4tv6NFYl6Im10+T0uZlgLjt6OGFavUi4VKbL9e36+YsVK9asb+aRVi1fr39flYwyq2/hU7PHpYKRdjZc56jdjDcm23XNtvxFq/GOvoAiOrEsRnRMQh7vj/lsk3iNJHhiNx4NjiGx8cH0rWH3PQn37jxPnHQP2ZRP1eIiTQ+gHjP+nAwnD8Tr/4d8mPf5fc5+X2Gf8KOBYk/LugOf8mSLB1sir/Yhz4/kCGdwrxbUmC9xVaLtHivsom5BNarrrxsYQA97M4oPliZuwis3/w/Bjw+g3kncC6IA77sUNYF/xyHuwwTMjkBdi3XYR91TjYbcQXQeVhUXF+mA5hXVja2trI51Jr6dW2HNxUmpeoQIrnZxe2kP2eHz/8jJDwe5MWNmX3tu4vbSTbCH4Ga1IF/ARSjJ+pKX6RkPD7PcjRysZWIudgQLaXjqrhJ5Bi/PY0xW8kZPmlu+l4l/IrkGL89jXFbzR8/ObudI1fmxTjV9IUv3Mhyy8F4dY85aK54PIrkGL8ypri90r4+N25nc+V5mr7XeDXJsX4fa8pfudDxu8+02K5fDf4CaQYvwNN8RsLef1yv6XFmhSFwOsXgRTjV9EUv1d7gJ+txWwGDIjfCSnGr6opfhd6gB/TYqnu+O+EFONX0wy/SaO7/duOBD/mXn6N7a+FaFQ7vuMTturA60uY237jNSnxe4wj1xD2Z2Ccx4yX8xstSnC+Cj63rNn0DGDhcXw1IP6T+SN/iajj4eWP5H4bOR43LfPvR7Rf7rgQx/ruzB9p7/Nl/LMwQP4hqD98HO/T8jYtMmF42Tiwqt9Spmfjinp2G/H7sWSeWOz2Xa5npVF8r32jNyGe9wua6eEJh8/HgO8jzrjniLc+TkXC1cc8fsuwrB81twsWXRfQESdquwK0eDwXNdPHY0Y4+ngWMPHDg2tlXfTxmIK8O9thHCcMsVbFcVuCI88LUcCxLfQa2begeMrkledtGQHk1fCQV5bm8B7gKgXVBcdxzeT1ekjrJ56v44mHYwk1TOunIJ9e5yOMA86Dxilo3kBYdiEKe0E/PuMCeFr02Mk6QXEdqBrP5nkX7tmY7fxFxfTNDrzfGPL9N298PNqdnMd98ghaGZmdsLvmS+tgNzgePB9aVZ5ldvQDwKIDB3G7rY0c430CzisZlN14A2IQVdrzwr7pyj9XBoBXN7gYAXExPHCZANm2JPsnVl/TzJ5GPOxp2PLH/YBu8ufcEJzJ38vJ3yVocyZ/nbi8N0Tyx9df/4qEs/6agpiv+6mW9jkLxWMwHXz3jcZ5shGP+Ea38jkroWdnHl5nGDC48vW9vEkBc4kX7UAMb5D+aTYW7rcf8/Ffz6C8H/HUTfBzOrrkh49DTpR9asvWEZfd5AAa4Hn8mJzlhzv9CT9I1tHXBrQ/m0G2Bu/TXoecJPvUElE+39Qt//I49qQRThyb5/GIpwnbcRefY4cd8xQdED8H9Vv0Ku/eLz7H4wWqYTnczzgZ3DmJEQdu24DX44ha3oqfnogr4svXadlcIn0vkbnH452qeEY5oYQPPienI2/+UPIebn9X7m9sZJczyWTa/v4LYp+xVcYRvQDjeJecjvx5GY6XwGatbW4mM9m1r5OOcc8HwRG9AOP4xYBw7PA/hGRvOG7iafL2/t7n2HlHv64OSB/6+WMxbkH137bPOmkd5UfIcYuuu+H24YD4ip9HJj22w9xv7X4Lgcf5NwkB7ueVAfEd9ivxe0T6dW6Ny+92pVArWCtzd+B7fo+GP55RgRTj+g453efWEH635rvGzybF+E2dMnvxNvgj8a0gfJ/ld30I7te05vaC7+tGA9oLGX6vwXgP8vP5OUdc2g+3KBBg/N4fsN0Y7bPdEG+TUbAbiAD3801N7Max4c2H3K5MB8zj/MknfnqQz9L1b3IrT3dhzD+ytEX3YvnNNbgOhbB92Z+U8I16vgrjfnnAfDvtIfcRh9xPhy73m4kdR56iEq6UBOP3liZx/XiXfNXt/VG9smsyPzi/X8LH/d3Rr4wmeiVu9MYf5MfnK2uZbA5ySD/wxi/K27rhmB3S9acqXtxfnU0ub6XvedgzB168rRteOfL/cc5LvPXN45wXaojx+m7I88z4PZaHI+HGfy6CnVw1m679/asm9oePPxUwH3nWJ/5Cxy1kkg1T3nE/4+P83OqB+Sh/aJl75WP7JkI3ftElPm6g+BTxkDfVOCDnw4mQ+JDjavNhO6Nq2PLfz/Upj4rbUdrjo0rTnf8+Jfrmv/fLfnL9Jt6C6uG3Rg0xrvkht58v+PeRcPUix7mBcMb9fqCJHX2BalX9FffJT3OMX0t7+rLn7jhes5FwcHsXdL+I23Dqf6OP65Ag8jY1ILzCWGdwP+DPPvy2o+gH5Ofv1G65Jif3u3d5TXbHfKxonmfar3w7ngdeAqAwTqvwbx3Wz6M9WD9zP1UpEsy/LbungJ+z9b513eN+LB9CPD9LGvPxqEZ8vAzx1mHVv4vofltVPv1RghePm/rd7i/Nq1P7swAd85AmZ3nOKvy6pYHeJS78yP2g4l9zCP73H3Tbn8rGJfXvooZ4/v5ySvanvVovZ+noN+HsmVu/10/5/tQx/lO5Px1DeeGq8aqUj5+Nn6/g+fWSYxUdOH5yZneEvFHZvTk3yGDOfc6g+Ca2O7LzKUH/Ppaq3flfAAAA///6iGIIGG4AAA==";

  // Deserialize RuntimeTypeInfo
  var bytes = BASE64.decode(serializedRuntimeTypeInfo);
  var unzippedBytes = new ZLibDecoder().convert(bytes);
  var bdata = new ByteData.view(unzippedBytes.buffer);
  var message = new bindings.Message(bdata, null, unzippedBytes.length, 0);
  _runtimeTypeInfo = mojom_types.RuntimeTypeInfo.deserialize(message);
  return _runtimeTypeInfo;
}
