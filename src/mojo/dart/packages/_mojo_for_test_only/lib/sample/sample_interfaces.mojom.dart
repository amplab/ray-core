// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library sample_interfaces_mojom;
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/mojom_types.mojom.dart' as mojom_types;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;
const int kLong = 4405;

class Enum extends bindings.MojoEnum {
  static const Enum value = const Enum._(0);

  const Enum._(int v) : super(v);

  static const Map<String, Enum> valuesMap = const {
    "value": value,
  };
  static const List<Enum> values = const [
    value,
  ];

  static Enum valueOf(String name) => valuesMap[name];

  factory Enum(int v) {
    switch (v) {
      case 0:
        return Enum.value;
      default:
        return null;
    }
  }

  static Enum decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    Enum result = new Enum(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum Enum.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case value:
        return 'Enum.value';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}



class _ProviderEchoStringParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String a = null;

  _ProviderEchoStringParams() : super(kVersions.last.size);

  _ProviderEchoStringParams.init(
    String this.a
  ) : super(kVersions.last.size);

  static _ProviderEchoStringParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ProviderEchoStringParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ProviderEchoStringParams result = new _ProviderEchoStringParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.a = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ProviderEchoStringParams";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeString(a, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ProviderEchoStringParams("
           "a: $a" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    return map;
  }
}


class ProviderEchoStringResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  String a = null;

  ProviderEchoStringResponseParams() : super(kVersions.last.size);

  ProviderEchoStringResponseParams.init(
    String this.a
  ) : super(kVersions.last.size);

  static ProviderEchoStringResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ProviderEchoStringResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ProviderEchoStringResponseParams result = new ProviderEchoStringResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.a = decoder0.decodeString(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ProviderEchoStringResponseParams";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeString(a, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ProviderEchoStringResponseParams("
           "a: $a" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    return map;
  }
}


class _ProviderEchoStringsParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  String a = null;
  String b = null;

  _ProviderEchoStringsParams() : super(kVersions.last.size);

  _ProviderEchoStringsParams.init(
    String this.a, 
    String this.b
  ) : super(kVersions.last.size);

  static _ProviderEchoStringsParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ProviderEchoStringsParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ProviderEchoStringsParams result = new _ProviderEchoStringsParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.a = decoder0.decodeString(8, false);
    }
    if (mainDataHeader.version >= 0) {
      
      result.b = decoder0.decodeString(16, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ProviderEchoStringsParams";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeString(a, 8, false);
      fieldName = "b";
      encoder0.encodeString(b, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ProviderEchoStringsParams("
           "a: $a" ", "
           "b: $b" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    map["b"] = b;
    return map;
  }
}


class ProviderEchoStringsResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  String a = null;
  String b = null;

  ProviderEchoStringsResponseParams() : super(kVersions.last.size);

  ProviderEchoStringsResponseParams.init(
    String this.a, 
    String this.b
  ) : super(kVersions.last.size);

  static ProviderEchoStringsResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ProviderEchoStringsResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ProviderEchoStringsResponseParams result = new ProviderEchoStringsResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.a = decoder0.decodeString(8, false);
    }
    if (mainDataHeader.version >= 0) {
      
      result.b = decoder0.decodeString(16, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ProviderEchoStringsResponseParams";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeString(a, 8, false);
      fieldName = "b";
      encoder0.encodeString(b, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ProviderEchoStringsResponseParams("
           "a: $a" ", "
           "b: $b" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    map["b"] = b;
    return map;
  }
}


class _ProviderEchoMessagePipeHandleParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  core.MojoMessagePipeEndpoint a = null;

  _ProviderEchoMessagePipeHandleParams() : super(kVersions.last.size);

  _ProviderEchoMessagePipeHandleParams.init(
    core.MojoMessagePipeEndpoint this.a
  ) : super(kVersions.last.size);

  static _ProviderEchoMessagePipeHandleParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ProviderEchoMessagePipeHandleParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ProviderEchoMessagePipeHandleParams result = new _ProviderEchoMessagePipeHandleParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.a = decoder0.decodeMessagePipeHandle(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ProviderEchoMessagePipeHandleParams";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeMessagePipeHandle(a, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ProviderEchoMessagePipeHandleParams("
           "a: $a" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class ProviderEchoMessagePipeHandleResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  core.MojoMessagePipeEndpoint a = null;

  ProviderEchoMessagePipeHandleResponseParams() : super(kVersions.last.size);

  ProviderEchoMessagePipeHandleResponseParams.init(
    core.MojoMessagePipeEndpoint this.a
  ) : super(kVersions.last.size);

  static ProviderEchoMessagePipeHandleResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ProviderEchoMessagePipeHandleResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ProviderEchoMessagePipeHandleResponseParams result = new ProviderEchoMessagePipeHandleResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.a = decoder0.decodeMessagePipeHandle(8, false);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ProviderEchoMessagePipeHandleResponseParams";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeMessagePipeHandle(a, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ProviderEchoMessagePipeHandleResponseParams("
           "a: $a" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _ProviderEchoEnumParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Enum a = null;

  _ProviderEchoEnumParams() : super(kVersions.last.size);

  _ProviderEchoEnumParams.init(
    Enum this.a
  ) : super(kVersions.last.size);

  static _ProviderEchoEnumParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ProviderEchoEnumParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ProviderEchoEnumParams result = new _ProviderEchoEnumParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.a = Enum.decode(decoder0, 8);
        if (result.a == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Enum.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ProviderEchoEnumParams";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeEnum(a, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ProviderEchoEnumParams("
           "a: $a" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    return map;
  }
}


class ProviderEchoEnumResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Enum a = null;

  ProviderEchoEnumResponseParams() : super(kVersions.last.size);

  ProviderEchoEnumResponseParams.init(
    Enum this.a
  ) : super(kVersions.last.size);

  static ProviderEchoEnumResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ProviderEchoEnumResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ProviderEchoEnumResponseParams result = new ProviderEchoEnumResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.a = Enum.decode(decoder0, 8);
        if (result.a == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Enum.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ProviderEchoEnumResponseParams";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeEnum(a, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ProviderEchoEnumResponseParams("
           "a: $a" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    return map;
  }
}


class _ProviderEchoIntParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int a = 0;

  _ProviderEchoIntParams() : super(kVersions.last.size);

  _ProviderEchoIntParams.init(
    int this.a
  ) : super(kVersions.last.size);

  static _ProviderEchoIntParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ProviderEchoIntParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ProviderEchoIntParams result = new _ProviderEchoIntParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.a = decoder0.decodeInt32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ProviderEchoIntParams";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeInt32(a, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ProviderEchoIntParams("
           "a: $a" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    return map;
  }
}


class ProviderEchoIntResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int a = 0;

  ProviderEchoIntResponseParams() : super(kVersions.last.size);

  ProviderEchoIntResponseParams.init(
    int this.a
  ) : super(kVersions.last.size);

  static ProviderEchoIntResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ProviderEchoIntResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ProviderEchoIntResponseParams result = new ProviderEchoIntResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.a = decoder0.decodeInt32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ProviderEchoIntResponseParams";
    String fieldName;
    try {
      fieldName = "a";
      encoder0.encodeInt32(a, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ProviderEchoIntResponseParams("
           "a: $a" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a"] = a;
    return map;
  }
}


class _IntegerAccessorGetIntegerParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _IntegerAccessorGetIntegerParams() : super(kVersions.last.size);

  _IntegerAccessorGetIntegerParams.init(
  ) : super(kVersions.last.size);

  static _IntegerAccessorGetIntegerParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _IntegerAccessorGetIntegerParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _IntegerAccessorGetIntegerParams result = new _IntegerAccessorGetIntegerParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_IntegerAccessorGetIntegerParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_IntegerAccessorGetIntegerParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class IntegerAccessorGetIntegerResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0),
    const bindings.StructDataHeader(24, 2)
  ];
  int data = 0;
  Enum type = null;

  IntegerAccessorGetIntegerResponseParams() : super(kVersions.last.size);

  IntegerAccessorGetIntegerResponseParams.init(
    int this.data, 
    Enum this.type
  ) : super(kVersions.last.size);

  static IntegerAccessorGetIntegerResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static IntegerAccessorGetIntegerResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    IntegerAccessorGetIntegerResponseParams result = new IntegerAccessorGetIntegerResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.data = decoder0.decodeInt64(8);
    }
    if (mainDataHeader.version >= 2) {
      
        result.type = Enum.decode(decoder0, 16);
        if (result.type == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Enum.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "IntegerAccessorGetIntegerResponseParams";
    String fieldName;
    try {
      fieldName = "data";
      encoder0.encodeInt64(data, 8);
      fieldName = "type";
      encoder0.encodeEnum(type, 16);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "IntegerAccessorGetIntegerResponseParams("
           "data: $data" ", "
           "type: $type" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["data"] = data;
    map["type"] = type;
    return map;
  }
}


class _IntegerAccessorSetIntegerParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0),
    const bindings.StructDataHeader(24, 3)
  ];
  int data = 0;
  Enum type = null;

  _IntegerAccessorSetIntegerParams() : super(kVersions.last.size);

  _IntegerAccessorSetIntegerParams.init(
    int this.data, 
    Enum this.type
  ) : super(kVersions.last.size);

  static _IntegerAccessorSetIntegerParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _IntegerAccessorSetIntegerParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _IntegerAccessorSetIntegerParams result = new _IntegerAccessorSetIntegerParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.data = decoder0.decodeInt64(8);
    }
    if (mainDataHeader.version >= 3) {
      
        result.type = Enum.decode(decoder0, 16);
        if (result.type == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Enum.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_IntegerAccessorSetIntegerParams";
    String fieldName;
    try {
      fieldName = "data";
      encoder0.encodeInt64(data, 8);
      fieldName = "type";
      encoder0.encodeEnum(type, 16);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_IntegerAccessorSetIntegerParams("
           "data: $data" ", "
           "type: $type" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["data"] = data;
    map["type"] = type;
    return map;
  }
}


class _SampleInterfaceSampleMethod1Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  int in1 = 0;
  String in2 = null;

  _SampleInterfaceSampleMethod1Params() : super(kVersions.last.size);

  _SampleInterfaceSampleMethod1Params.init(
    int this.in1, 
    String this.in2
  ) : super(kVersions.last.size);

  static _SampleInterfaceSampleMethod1Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _SampleInterfaceSampleMethod1Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _SampleInterfaceSampleMethod1Params result = new _SampleInterfaceSampleMethod1Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.in1 = decoder0.decodeInt32(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.in2 = decoder0.decodeString(16, true);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_SampleInterfaceSampleMethod1Params";
    String fieldName;
    try {
      fieldName = "in1";
      encoder0.encodeInt32(in1, 8);
      fieldName = "in2";
      encoder0.encodeString(in2, 16, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_SampleInterfaceSampleMethod1Params("
           "in1: $in1" ", "
           "in2: $in2" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["in1"] = in1;
    map["in2"] = in2;
    return map;
  }
}


class SampleInterfaceSampleMethod1ResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  String out1 = null;
  Enum out2 = null;

  SampleInterfaceSampleMethod1ResponseParams() : super(kVersions.last.size);

  SampleInterfaceSampleMethod1ResponseParams.init(
    String this.out1, 
    Enum this.out2
  ) : super(kVersions.last.size);

  static SampleInterfaceSampleMethod1ResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static SampleInterfaceSampleMethod1ResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    SampleInterfaceSampleMethod1ResponseParams result = new SampleInterfaceSampleMethod1ResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.out1 = decoder0.decodeString(8, true);
    }
    if (mainDataHeader.version >= 0) {
      
        result.out2 = Enum.decode(decoder0, 16);
        if (result.out2 == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable Enum.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "SampleInterfaceSampleMethod1ResponseParams";
    String fieldName;
    try {
      fieldName = "out1";
      encoder0.encodeString(out1, 8, true);
      fieldName = "out2";
      encoder0.encodeEnum(out2, 16);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "SampleInterfaceSampleMethod1ResponseParams("
           "out1: $out1" ", "
           "out2: $out2" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["out1"] = out1;
    map["out2"] = out2;
    return map;
  }
}


class _SampleInterfaceSampleMethod0Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _SampleInterfaceSampleMethod0Params() : super(kVersions.last.size);

  _SampleInterfaceSampleMethod0Params.init(
  ) : super(kVersions.last.size);

  static _SampleInterfaceSampleMethod0Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _SampleInterfaceSampleMethod0Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _SampleInterfaceSampleMethod0Params result = new _SampleInterfaceSampleMethod0Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_SampleInterfaceSampleMethod0Params";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_SampleInterfaceSampleMethod0Params("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class _SampleInterfaceSampleMethod2Params extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _SampleInterfaceSampleMethod2Params() : super(kVersions.last.size);

  _SampleInterfaceSampleMethod2Params.init(
  ) : super(kVersions.last.size);

  static _SampleInterfaceSampleMethod2Params deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _SampleInterfaceSampleMethod2Params decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _SampleInterfaceSampleMethod2Params result = new _SampleInterfaceSampleMethod2Params();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_SampleInterfaceSampleMethod2Params";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_SampleInterfaceSampleMethod2Params("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}

const int _providerMethodEchoStringName = 0;
const int _providerMethodEchoStringsName = 1;
const int _providerMethodEchoMessagePipeHandleName = 2;
const int _providerMethodEchoEnumName = 3;
const int _providerMethodEchoIntName = 4;

class _ProviderServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class Provider {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _ProviderServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static ProviderProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    ProviderProxy p = new ProviderProxy.unbound();
    String name = serviceName ?? Provider.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void echoString(String a,void callback(String a));
  void echoStrings(String a,String b,void callback(String a, String b));
  void echoMessagePipeHandle(core.MojoMessagePipeEndpoint a,void callback(core.MojoMessagePipeEndpoint a));
  void echoEnum(Enum a,void callback(Enum a));
  void echoInt(int a,void callback(int a));
}

abstract class ProviderInterface
    implements bindings.MojoInterface<Provider>,
               Provider {
  factory ProviderInterface([Provider impl]) =>
      new ProviderStub.unbound(impl);

  factory ProviderInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [Provider impl]) =>
      new ProviderStub.fromEndpoint(endpoint, impl);

  factory ProviderInterface.fromMock(
      Provider mock) =>
      new ProviderProxy.fromMock(mock);
}

abstract class ProviderInterfaceRequest
    implements bindings.MojoInterface<Provider>,
               Provider {
  factory ProviderInterfaceRequest() =>
      new ProviderProxy.unbound();
}

class _ProviderProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<Provider> {
  Provider impl;

  _ProviderProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _ProviderProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _ProviderProxyControl.unbound() : super.unbound();

  String get serviceName => Provider.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _providerMethodEchoStringName:
        var r = ProviderEchoStringResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.a );
        break;
      case _providerMethodEchoStringsName:
        var r = ProviderEchoStringsResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.a , r.b );
        break;
      case _providerMethodEchoMessagePipeHandleName:
        var r = ProviderEchoMessagePipeHandleResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.a );
        break;
      case _providerMethodEchoEnumName:
        var r = ProviderEchoEnumResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.a );
        break;
      case _providerMethodEchoIntName:
        var r = ProviderEchoIntResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.a );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ProviderProxyControl($superString)";
  }
}

class ProviderProxy
    extends bindings.Proxy<Provider>
    implements Provider,
               ProviderInterface,
               ProviderInterfaceRequest {
  ProviderProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _ProviderProxyControl.fromEndpoint(endpoint));

  ProviderProxy.fromHandle(core.MojoHandle handle)
      : super(new _ProviderProxyControl.fromHandle(handle));

  ProviderProxy.unbound()
      : super(new _ProviderProxyControl.unbound());

  factory ProviderProxy.fromMock(Provider mock) {
    ProviderProxy newMockedProxy =
        new ProviderProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static ProviderProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ProviderProxy"));
    return new ProviderProxy.fromEndpoint(endpoint);
  }


  void echoString(String a,void callback(String a)) {
    if (impl != null) {
      impl.echoString(a,callback);
      return;
    }
    var params = new _ProviderEchoStringParams();
    params.a = a;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((String a) {
        z.bindCallback(() {
          callback(a);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _providerMethodEchoStringName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void echoStrings(String a,String b,void callback(String a, String b)) {
    if (impl != null) {
      impl.echoStrings(a,b,callback);
      return;
    }
    var params = new _ProviderEchoStringsParams();
    params.a = a;
    params.b = b;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((String a, String b) {
        z.bindCallback(() {
          callback(a, b);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _providerMethodEchoStringsName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void echoMessagePipeHandle(core.MojoMessagePipeEndpoint a,void callback(core.MojoMessagePipeEndpoint a)) {
    if (impl != null) {
      impl.echoMessagePipeHandle(a,callback);
      return;
    }
    var params = new _ProviderEchoMessagePipeHandleParams();
    params.a = a;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((core.MojoMessagePipeEndpoint a) {
        z.bindCallback(() {
          callback(a);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _providerMethodEchoMessagePipeHandleName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void echoEnum(Enum a,void callback(Enum a)) {
    if (impl != null) {
      impl.echoEnum(a,callback);
      return;
    }
    var params = new _ProviderEchoEnumParams();
    params.a = a;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((Enum a) {
        z.bindCallback(() {
          callback(a);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _providerMethodEchoEnumName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void echoInt(int a,void callback(int a)) {
    if (impl != null) {
      impl.echoInt(a,callback);
      return;
    }
    var params = new _ProviderEchoIntParams();
    params.a = a;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((int a) {
        z.bindCallback(() {
          callback(a);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _providerMethodEchoIntName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _ProviderStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<Provider> {
  Provider _impl;

  _ProviderStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Provider impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _ProviderStubControl.fromHandle(
      core.MojoHandle handle, [Provider impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _ProviderStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => Provider.serviceName;


  Function _providerEchoStringResponseParamsResponder(
      int requestId) {
  return (String a) {
      var result = new ProviderEchoStringResponseParams();
      result.a = a;
      sendResponse(buildResponseWithId(
          result,
          _providerMethodEchoStringName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _providerEchoStringsResponseParamsResponder(
      int requestId) {
  return (String a, String b) {
      var result = new ProviderEchoStringsResponseParams();
      result.a = a;
      result.b = b;
      sendResponse(buildResponseWithId(
          result,
          _providerMethodEchoStringsName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _providerEchoMessagePipeHandleResponseParamsResponder(
      int requestId) {
  return (core.MojoMessagePipeEndpoint a) {
      var result = new ProviderEchoMessagePipeHandleResponseParams();
      result.a = a;
      sendResponse(buildResponseWithId(
          result,
          _providerMethodEchoMessagePipeHandleName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _providerEchoEnumResponseParamsResponder(
      int requestId) {
  return (Enum a) {
      var result = new ProviderEchoEnumResponseParams();
      result.a = a;
      sendResponse(buildResponseWithId(
          result,
          _providerMethodEchoEnumName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _providerEchoIntResponseParamsResponder(
      int requestId) {
  return (int a) {
      var result = new ProviderEchoIntResponseParams();
      result.a = a;
      sendResponse(buildResponseWithId(
          result,
          _providerMethodEchoIntName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _providerMethodEchoStringName:
        var params = _ProviderEchoStringParams.deserialize(
            message.payload);
        _impl.echoString(params.a, _providerEchoStringResponseParamsResponder(message.header.requestId));
        break;
      case _providerMethodEchoStringsName:
        var params = _ProviderEchoStringsParams.deserialize(
            message.payload);
        _impl.echoStrings(params.a, params.b, _providerEchoStringsResponseParamsResponder(message.header.requestId));
        break;
      case _providerMethodEchoMessagePipeHandleName:
        var params = _ProviderEchoMessagePipeHandleParams.deserialize(
            message.payload);
        _impl.echoMessagePipeHandle(params.a, _providerEchoMessagePipeHandleResponseParamsResponder(message.header.requestId));
        break;
      case _providerMethodEchoEnumName:
        var params = _ProviderEchoEnumParams.deserialize(
            message.payload);
        _impl.echoEnum(params.a, _providerEchoEnumResponseParamsResponder(message.header.requestId));
        break;
      case _providerMethodEchoIntName:
        var params = _ProviderEchoIntParams.deserialize(
            message.payload);
        _impl.echoInt(params.a, _providerEchoIntResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  Provider get impl => _impl;
  set impl(Provider d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ProviderStubControl($superString)";
  }

  int get version => 0;
}

class ProviderStub
    extends bindings.Stub<Provider>
    implements Provider,
               ProviderInterface,
               ProviderInterfaceRequest {
  ProviderStub.unbound([Provider impl])
      : super(new _ProviderStubControl.unbound(impl));

  ProviderStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Provider impl])
      : super(new _ProviderStubControl.fromEndpoint(endpoint, impl));

  ProviderStub.fromHandle(
      core.MojoHandle handle, [Provider impl])
      : super(new _ProviderStubControl.fromHandle(handle, impl));

  static ProviderStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ProviderStub"));
    return new ProviderStub.fromEndpoint(endpoint);
  }


  void echoString(String a,void callback(String a)) {
    return impl.echoString(a,callback);
  }
  void echoStrings(String a,String b,void callback(String a, String b)) {
    return impl.echoStrings(a,b,callback);
  }
  void echoMessagePipeHandle(core.MojoMessagePipeEndpoint a,void callback(core.MojoMessagePipeEndpoint a)) {
    return impl.echoMessagePipeHandle(a,callback);
  }
  void echoEnum(Enum a,void callback(Enum a)) {
    return impl.echoEnum(a,callback);
  }
  void echoInt(int a,void callback(int a)) {
    return impl.echoInt(a,callback);
  }
}

const int _integerAccessorMethodGetIntegerName = 0;
const int _integerAccessorMethodSetIntegerName = 1;

class _IntegerAccessorServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class IntegerAccessor {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _IntegerAccessorServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static IntegerAccessorProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    IntegerAccessorProxy p = new IntegerAccessorProxy.unbound();
    String name = serviceName ?? IntegerAccessor.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void getInteger(void callback(int data, Enum type));
  void setInteger(int data, Enum type);
}

abstract class IntegerAccessorInterface
    implements bindings.MojoInterface<IntegerAccessor>,
               IntegerAccessor {
  factory IntegerAccessorInterface([IntegerAccessor impl]) =>
      new IntegerAccessorStub.unbound(impl);

  factory IntegerAccessorInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [IntegerAccessor impl]) =>
      new IntegerAccessorStub.fromEndpoint(endpoint, impl);

  factory IntegerAccessorInterface.fromMock(
      IntegerAccessor mock) =>
      new IntegerAccessorProxy.fromMock(mock);
}

abstract class IntegerAccessorInterfaceRequest
    implements bindings.MojoInterface<IntegerAccessor>,
               IntegerAccessor {
  factory IntegerAccessorInterfaceRequest() =>
      new IntegerAccessorProxy.unbound();
}

class _IntegerAccessorProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<IntegerAccessor> {
  IntegerAccessor impl;

  _IntegerAccessorProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _IntegerAccessorProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _IntegerAccessorProxyControl.unbound() : super.unbound();

  String get serviceName => IntegerAccessor.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _integerAccessorMethodGetIntegerName:
        var r = IntegerAccessorGetIntegerResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.data , r.type );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_IntegerAccessorProxyControl($superString)";
  }
}

class IntegerAccessorProxy
    extends bindings.Proxy<IntegerAccessor>
    implements IntegerAccessor,
               IntegerAccessorInterface,
               IntegerAccessorInterfaceRequest {
  IntegerAccessorProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _IntegerAccessorProxyControl.fromEndpoint(endpoint));

  IntegerAccessorProxy.fromHandle(core.MojoHandle handle)
      : super(new _IntegerAccessorProxyControl.fromHandle(handle));

  IntegerAccessorProxy.unbound()
      : super(new _IntegerAccessorProxyControl.unbound());

  factory IntegerAccessorProxy.fromMock(IntegerAccessor mock) {
    IntegerAccessorProxy newMockedProxy =
        new IntegerAccessorProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static IntegerAccessorProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For IntegerAccessorProxy"));
    return new IntegerAccessorProxy.fromEndpoint(endpoint);
  }


  void getInteger(void callback(int data, Enum type)) {
    if (impl != null) {
      impl.getInteger(callback);
      return;
    }
    var params = new _IntegerAccessorGetIntegerParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((int data, Enum type) {
        z.bindCallback(() {
          callback(data, type);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _integerAccessorMethodGetIntegerName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void setInteger(int data, Enum type) {
    if (impl != null) {
      impl.setInteger(data, type);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _IntegerAccessorSetIntegerParams();
    params.data = data;
    params.type = type;
    ctrl.sendMessage(params,
        _integerAccessorMethodSetIntegerName);
  }
}

class _IntegerAccessorStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<IntegerAccessor> {
  IntegerAccessor _impl;

  _IntegerAccessorStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [IntegerAccessor impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _IntegerAccessorStubControl.fromHandle(
      core.MojoHandle handle, [IntegerAccessor impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _IntegerAccessorStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => IntegerAccessor.serviceName;


  Function _integerAccessorGetIntegerResponseParamsResponder(
      int requestId) {
  return (int data, Enum type) {
      var result = new IntegerAccessorGetIntegerResponseParams();
      result.data = data;
      result.type = type;
      sendResponse(buildResponseWithId(
          result,
          _integerAccessorMethodGetIntegerName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 3, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _integerAccessorMethodGetIntegerName:
        _impl.getInteger(_integerAccessorGetIntegerResponseParamsResponder(message.header.requestId));
        break;
      case _integerAccessorMethodSetIntegerName:
        var params = _IntegerAccessorSetIntegerParams.deserialize(
            message.payload);
        _impl.setInteger(params.data, params.type);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  IntegerAccessor get impl => _impl;
  set impl(IntegerAccessor d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_IntegerAccessorStubControl($superString)";
  }

  int get version => 3;
}

class IntegerAccessorStub
    extends bindings.Stub<IntegerAccessor>
    implements IntegerAccessor,
               IntegerAccessorInterface,
               IntegerAccessorInterfaceRequest {
  IntegerAccessorStub.unbound([IntegerAccessor impl])
      : super(new _IntegerAccessorStubControl.unbound(impl));

  IntegerAccessorStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [IntegerAccessor impl])
      : super(new _IntegerAccessorStubControl.fromEndpoint(endpoint, impl));

  IntegerAccessorStub.fromHandle(
      core.MojoHandle handle, [IntegerAccessor impl])
      : super(new _IntegerAccessorStubControl.fromHandle(handle, impl));

  static IntegerAccessorStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For IntegerAccessorStub"));
    return new IntegerAccessorStub.fromEndpoint(endpoint);
  }


  void getInteger(void callback(int data, Enum type)) {
    return impl.getInteger(callback);
  }
  void setInteger(int data, Enum type) {
    return impl.setInteger(data, type);
  }
}

const int _sampleInterfaceMethodSampleMethod1Name = 1;
const int _sampleInterfaceMethodSampleMethod0Name = 0;
const int _sampleInterfaceMethodSampleMethod2Name = 2;

class _SampleInterfaceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class SampleInterface {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _SampleInterfaceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static SampleInterfaceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    SampleInterfaceProxy p = new SampleInterfaceProxy.unbound();
    String name = serviceName ?? SampleInterface.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void sampleMethod1(int in1,String in2,void callback(String out1, Enum out2));
  void sampleMethod0();
  void sampleMethod2();
}

abstract class SampleInterfaceInterface
    implements bindings.MojoInterface<SampleInterface>,
               SampleInterface {
  factory SampleInterfaceInterface([SampleInterface impl]) =>
      new SampleInterfaceStub.unbound(impl);

  factory SampleInterfaceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [SampleInterface impl]) =>
      new SampleInterfaceStub.fromEndpoint(endpoint, impl);

  factory SampleInterfaceInterface.fromMock(
      SampleInterface mock) =>
      new SampleInterfaceProxy.fromMock(mock);
}

abstract class SampleInterfaceInterfaceRequest
    implements bindings.MojoInterface<SampleInterface>,
               SampleInterface {
  factory SampleInterfaceInterfaceRequest() =>
      new SampleInterfaceProxy.unbound();
}

class _SampleInterfaceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<SampleInterface> {
  SampleInterface impl;

  _SampleInterfaceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _SampleInterfaceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _SampleInterfaceProxyControl.unbound() : super.unbound();

  String get serviceName => SampleInterface.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _sampleInterfaceMethodSampleMethod1Name:
        var r = SampleInterfaceSampleMethod1ResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.out1 , r.out2 );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_SampleInterfaceProxyControl($superString)";
  }
}

class SampleInterfaceProxy
    extends bindings.Proxy<SampleInterface>
    implements SampleInterface,
               SampleInterfaceInterface,
               SampleInterfaceInterfaceRequest {
  SampleInterfaceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _SampleInterfaceProxyControl.fromEndpoint(endpoint));

  SampleInterfaceProxy.fromHandle(core.MojoHandle handle)
      : super(new _SampleInterfaceProxyControl.fromHandle(handle));

  SampleInterfaceProxy.unbound()
      : super(new _SampleInterfaceProxyControl.unbound());

  factory SampleInterfaceProxy.fromMock(SampleInterface mock) {
    SampleInterfaceProxy newMockedProxy =
        new SampleInterfaceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static SampleInterfaceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For SampleInterfaceProxy"));
    return new SampleInterfaceProxy.fromEndpoint(endpoint);
  }


  void sampleMethod1(int in1,String in2,void callback(String out1, Enum out2)) {
    if (impl != null) {
      impl.sampleMethod1(in1,in2,callback);
      return;
    }
    var params = new _SampleInterfaceSampleMethod1Params();
    params.in1 = in1;
    params.in2 = in2;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((String out1, Enum out2) {
        z.bindCallback(() {
          callback(out1, out2);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _sampleInterfaceMethodSampleMethod1Name,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void sampleMethod0() {
    if (impl != null) {
      impl.sampleMethod0();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _SampleInterfaceSampleMethod0Params();
    ctrl.sendMessage(params,
        _sampleInterfaceMethodSampleMethod0Name);
  }
  void sampleMethod2() {
    if (impl != null) {
      impl.sampleMethod2();
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _SampleInterfaceSampleMethod2Params();
    ctrl.sendMessage(params,
        _sampleInterfaceMethodSampleMethod2Name);
  }
}

class _SampleInterfaceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<SampleInterface> {
  SampleInterface _impl;

  _SampleInterfaceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [SampleInterface impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _SampleInterfaceStubControl.fromHandle(
      core.MojoHandle handle, [SampleInterface impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _SampleInterfaceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => SampleInterface.serviceName;


  Function _sampleInterfaceSampleMethod1ResponseParamsResponder(
      int requestId) {
  return (String out1, Enum out2) {
      var result = new SampleInterfaceSampleMethod1ResponseParams();
      result.out1 = out1;
      result.out2 = out2;
      sendResponse(buildResponseWithId(
          result,
          _sampleInterfaceMethodSampleMethod1Name,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _sampleInterfaceMethodSampleMethod1Name:
        var params = _SampleInterfaceSampleMethod1Params.deserialize(
            message.payload);
        _impl.sampleMethod1(params.in1, params.in2, _sampleInterfaceSampleMethod1ResponseParamsResponder(message.header.requestId));
        break;
      case _sampleInterfaceMethodSampleMethod0Name:
        _impl.sampleMethod0();
        break;
      case _sampleInterfaceMethodSampleMethod2Name:
        _impl.sampleMethod2();
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  SampleInterface get impl => _impl;
  set impl(SampleInterface d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_SampleInterfaceStubControl($superString)";
  }

  int get version => 0;
}

class SampleInterfaceStub
    extends bindings.Stub<SampleInterface>
    implements SampleInterface,
               SampleInterfaceInterface,
               SampleInterfaceInterfaceRequest {
  SampleInterfaceStub.unbound([SampleInterface impl])
      : super(new _SampleInterfaceStubControl.unbound(impl));

  SampleInterfaceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [SampleInterface impl])
      : super(new _SampleInterfaceStubControl.fromEndpoint(endpoint, impl));

  SampleInterfaceStub.fromHandle(
      core.MojoHandle handle, [SampleInterface impl])
      : super(new _SampleInterfaceStubControl.fromHandle(handle, impl));

  static SampleInterfaceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For SampleInterfaceStub"));
    return new SampleInterfaceStub.fromEndpoint(endpoint);
  }


  void sampleMethod1(int in1,String in2,void callback(String out1, Enum out2)) {
    return impl.sampleMethod1(in1,in2,callback);
  }
  void sampleMethod0() {
    return impl.sampleMethod0();
  }
  void sampleMethod2() {
    return impl.sampleMethod2();
  }
}


mojom_types.RuntimeTypeInfo getRuntimeTypeInfo() => _runtimeTypeInfo ??
    _initRuntimeTypeInfo();

Map<String, mojom_types.UserDefinedType> getAllMojomTypeDefinitions() {
  return getRuntimeTypeInfo().typeMap;
}

var _runtimeTypeInfo;
mojom_types.RuntimeTypeInfo  _initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this
  // file. The string contains the base64 encoding of the gzip-compressed bytes.
  var serializedRuntimeTypeInfo = "H4sIAAAJbogC/+xb3XLbRBSWLKeElkLaJOD01y1T8E0i28xAhivnwoMzkBnPBDrpVevYi+2OLRlJZgJPwCPwCFzyCDwCj8Jl7ugqPqderXdlyZajVZKdObPRn1f76Tvf2T27KWiTsgF1GWr+PNbrXM3f9w/UJWp5akU43of6BOoR1I+obVH78VWz/vr7+qtv3dZwNCB7dWs89K9/Se2p4Pqh5ZEucQ7abeK6tnPRTkFwX9Oxf+13iCP7neOLyv815+dWm2gNeO8N7r39Y4Pam1zw+K9PgsdaRYzLOdQ1LVjKXDv/Q+Hvw/IRvB/is0ntDjUOtpn2/efWqL2ldkrNHLuOObDbrYHZte3ugJg9e0jM352WObTf2lXTddoXf5mj8emg3zb7CJFrnvatTt/quqZHXM81J02/nt6w5z83nLavM3wpQV3UwktUnBqS5+9Cf18e/PBTndY71O4FcdrDayK8/OdzKeAlw2dDn9TGHHxqHD5NCT6fUfOpy/vRE3ru0ylO/OUZnPzj2yngJHoPPAYXveBdAY7xvrNbYpzRP0u5aDzUGJxF57HcB3y+Ix5gKX7/nZT4VuTwO4+oVxrHs31J/x8ABtP+7zrklzF9MTEOWC4bh3VNrFcF7r3WtXDc/jWSwe0haHsAN3dkWy5RCjfev4p6sP/73Hve0qKVqH5XmhMnOy2vJfO3nRTwEuHix6mGLu4H8i2niZ8/E+CiM+MrvvD8Lgr002DaQ/066lsvieP2bSuIr/fbiMjw/SpFPdMk8YEfP80bf87wW6ALuqCdHFhBMu6pcd9bB4v6fc+W/L76nO+L54/nxK2HisWtpPQX49ax4nErq/qL8S0r+mtcsv4aS+qvj+/uNdZfY47+Bh5eYN5ZC/m+/rfFvAPOs7h0hDC/osI8qsTkZdYYiHKAaZ7BZY25/xxuLn0Mv7c1qZsPwudbJ8Zq5lv1ds8+9hwKg7if9xSLWzjvTCpuTfuvZtzidVCky7rAP1cVrz6EplqanC9bKeEUFj9kOrhqnmH8DvBMwflpFnn2PEM8k+n6H/lgeI2Cmx6i65jnnvLNFeJ3XzFdPzFW5W9uQNhVnY+U9Wz4nc+bbQX8Li5O6wvgpEfA6TQEp6eK6xM77l+1X+L8JeiX00B445fL++XujV9G8stvMuSXM/NxwLFniPPdYbjlmO/Cl8eg675/HhHXbXVJsz8ijZbVGRABjpuKjB8Qj3LM8bosL/ECsBDiwIwksjRuzyukU5sK6JS+xPwwab59Qe1JCN8wQt7wbXG+HWaIb7ze/4fzRCPavhYWNyMEN8y/+rzzc8g8bluK6Dv2/01Mf5PNjwvQR+w3SnqW/GtNIf/agr+zvn6ybL6wl1C+EPffMfxksoXZigOq8fTRNeKpLI7sQwDJx8A9H4K7v2b3AfD10PJmcN9WLI5sJBRHcL0S+v1+ZpAl/9SYtcu0/XM7pTiyqO4nzSd2XDLh00T2b/i0OJ8eK8ynefvX5+FU43g1b/86//8b3P51/vIMnkVF9l0UmXhucPsu8LrBPNeEC3/fDl+Hi8tPbFfmzz7/7r7H/Yh4PbtTFvTnuXY197NjPjHQfwXzZ3H3s8v4cxZzHVcP4ZWMPxUBbs8U40/DWB1/KgryJ+6+0suKj3dAB/tWRaijz+CcCvtKL3N9aIpLVYrLixTzhXpC67Z/JuSHOE7g/VC1vLSq67Y4v7fHXkXGt68V4Fvc/E3SfsngVJXhdHDF8zdh6778ODXqui/+f02ccUZVgP/n12icWr0C49R3AQAA//8untFvsEAAAA==";

  // Deserialize RuntimeTypeInfo
  var bytes = BASE64.decode(serializedRuntimeTypeInfo);
  var unzippedBytes = new ZLibDecoder().convert(bytes);
  var bdata = new ByteData.view(unzippedBytes.buffer);
  var message = new bindings.Message(bdata, null, unzippedBytes.length, 0);
  _runtimeTypeInfo = mojom_types.RuntimeTypeInfo.deserialize(message);
  return _runtimeTypeInfo;
}
