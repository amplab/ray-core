// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library sample_service_mojom;
import 'dart:async';
import 'dart:collection';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/mojom_types.mojom.dart' as mojom_types;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;
import 'package:_mojo_for_test_only/imported/sample_import.mojom.dart' as sample_import_mojom;
import 'package:_mojo_for_test_only/imported/sample_import2.mojom.dart' as sample_import2_mojom;
const int kTwelve = 12;



class BarType extends bindings.MojoEnum {
  static const BarType vertical = const BarType._(1);
  static const BarType horizontal = const BarType._(2);
  static const BarType both = const BarType._(3);
  static const BarType invalid = const BarType._(4);

  const BarType._(int v) : super(v);

  static const Map<String, BarType> valuesMap = const {
    "vertical": vertical,
    "horizontal": horizontal,
    "both": both,
    "invalid": invalid,
  };
  static const List<BarType> values = const [
    vertical,
    horizontal,
    both,
    invalid,
  ];

  static BarType valueOf(String name) => valuesMap[name];

  factory BarType(int v) {
    switch (v) {
      case 1:
        return BarType.vertical;
      case 2:
        return BarType.horizontal;
      case 3:
        return BarType.both;
      case 4:
        return BarType.invalid;
      default:
        return null;
    }
  }

  static BarType decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    BarType result = new BarType(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum BarType.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case vertical:
        return 'BarType.vertical';
      case horizontal:
        return 'BarType.horizontal';
      case both:
        return 'BarType.both';
      case invalid:
        return 'BarType.invalid';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class Bar extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int alpha = 255;
  int beta = 0;
  int gamma = 0;
  BarType type = new BarType(1);

  Bar() : super(kVersions.last.size);

  Bar.init(
    int this.alpha, 
    int this.beta, 
    int this.gamma, 
    BarType this.type
  ) : super(kVersions.last.size);

  static Bar deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Bar decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Bar result = new Bar();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.alpha = decoder0.decodeUint8(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.beta = decoder0.decodeUint8(9);
    }
    if (mainDataHeader.version >= 0) {
      
      result.gamma = decoder0.decodeUint8(10);
    }
    if (mainDataHeader.version >= 0) {
      
        result.type = BarType.decode(decoder0, 12);
        if (result.type == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable BarType.');
        }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Bar";
    String fieldName;
    try {
      fieldName = "alpha";
      encoder0.encodeUint8(alpha, 8);
      fieldName = "beta";
      encoder0.encodeUint8(beta, 9);
      fieldName = "gamma";
      encoder0.encodeUint8(gamma, 10);
      fieldName = "type";
      encoder0.encodeEnum(type, 12);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Bar("
           "alpha: $alpha" ", "
           "beta: $beta" ", "
           "gamma: $gamma" ", "
           "type: $type" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["alpha"] = alpha;
    map["beta"] = beta;
    map["gamma"] = gamma;
    map["type"] = type;
    return map;
  }
}


class Foo extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(96, 0)
  ];
  static const String kFooby = "Fooby";
  int x = 0;
  int y = 0;
  bool a = true;
  bool b = false;
  bool c = false;
  core.MojoMessagePipeEndpoint source = null;
  Bar bar = null;
  List<int> data = null;
  List<Bar> extraBars = null;
  String name = "Fooby";
  List<core.MojoDataPipeConsumer> inputStreams = null;
  List<core.MojoDataPipeProducer> outputStreams = null;
  List<List<bool>> arrayOfArrayOfBools = null;
  List<List<List<String>>> multiArrayOfStrings = null;
  List<bool> arrayOfBools = null;

  Foo() : super(kVersions.last.size);

  Foo.init(
    int this.x, 
    int this.y, 
    bool this.a, 
    bool this.b, 
    bool this.c, 
    core.MojoMessagePipeEndpoint this.source, 
    Bar this.bar, 
    List<int> this.data, 
    List<Bar> this.extraBars, 
    String this.name, 
    List<core.MojoDataPipeConsumer> this.inputStreams, 
    List<core.MojoDataPipeProducer> this.outputStreams, 
    List<List<bool>> this.arrayOfArrayOfBools, 
    List<List<List<String>>> this.multiArrayOfStrings, 
    List<bool> this.arrayOfBools
  ) : super(kVersions.last.size);

  static Foo deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static Foo decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    Foo result = new Foo();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.x = decoder0.decodeInt32(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.y = decoder0.decodeInt32(12);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a = decoder0.decodeBool(16, 0);
    }
    if (mainDataHeader.version >= 0) {
      
      result.b = decoder0.decodeBool(16, 1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.c = decoder0.decodeBool(16, 2);
    }
    if (mainDataHeader.version >= 0) {
      
      result.source = decoder0.decodeMessagePipeHandle(20, true);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(24, true);
      result.bar = Bar.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.data = decoder0.decodeUint8Array(32, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(40, true);
      if (decoder1 == null) {
        result.extraBars = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.extraBars = new List<Bar>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          result.extraBars[i1] = Bar.decode(decoder2);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      result.name = decoder0.decodeString(48, false);
    }
    if (mainDataHeader.version >= 0) {
      
      result.inputStreams = decoder0.decodeConsumerHandleArray(56, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.outputStreams = decoder0.decodeProducerHandleArray(64, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(72, true);
      if (decoder1 == null) {
        result.arrayOfArrayOfBools = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.arrayOfArrayOfBools = new List<List<bool>>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          result.arrayOfArrayOfBools[i1] = decoder1.decodeBoolArray(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(80, true);
      if (decoder1 == null) {
        result.multiArrayOfStrings = null;
      } else {
        var si1 = decoder1.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
        result.multiArrayOfStrings = new List<List<List<String>>>(si1.numElements);
        for (int i1 = 0; i1 < si1.numElements; ++i1) {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          {
            var si2 = decoder2.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
            result.multiArrayOfStrings[i1] = new List<List<String>>(si2.numElements);
            for (int i2 = 0; i2 < si2.numElements; ++i2) {
              
              var decoder3 = decoder2.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i2, false);
              {
                var si3 = decoder3.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
                result.multiArrayOfStrings[i1][i2] = new List<String>(si3.numElements);
                for (int i3 = 0; i3 < si3.numElements; ++i3) {
                  
                  result.multiArrayOfStrings[i1][i2][i3] = decoder3.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i3, false);
                }
              }
            }
          }
        }
      }
    }
    if (mainDataHeader.version >= 0) {
      
      result.arrayOfBools = decoder0.decodeBoolArray(88, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "Foo";
    String fieldName;
    try {
      fieldName = "x";
      encoder0.encodeInt32(x, 8);
      fieldName = "y";
      encoder0.encodeInt32(y, 12);
      fieldName = "a";
      encoder0.encodeBool(a, 16, 0);
      fieldName = "b";
      encoder0.encodeBool(b, 16, 1);
      fieldName = "c";
      encoder0.encodeBool(c, 16, 2);
      fieldName = "source";
      encoder0.encodeMessagePipeHandle(source, 20, true);
      fieldName = "bar";
      encoder0.encodeStruct(bar, 24, true);
      fieldName = "data";
      encoder0.encodeUint8Array(data, 32, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "extraBars";
      if (extraBars == null) {
        encoder0.encodeNullPointer(40, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(extraBars.length, 40, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < extraBars.length; ++i0) {
          encoder1.encodeStruct(extraBars[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
        }
      }
      fieldName = "name";
      encoder0.encodeString(name, 48, false);
      fieldName = "inputStreams";
      encoder0.encodeConsumerHandleArray(inputStreams, 56, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "outputStreams";
      encoder0.encodeProducerHandleArray(outputStreams, 64, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "arrayOfArrayOfBools";
      if (arrayOfArrayOfBools == null) {
        encoder0.encodeNullPointer(72, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(arrayOfArrayOfBools.length, 72, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < arrayOfArrayOfBools.length; ++i0) {
          encoder1.encodeBoolArray(arrayOfArrayOfBools[i0], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
        }
      }
      fieldName = "multiArrayOfStrings";
      if (multiArrayOfStrings == null) {
        encoder0.encodeNullPointer(80, true);
      } else {
        var encoder1 = encoder0.encodePointerArray(multiArrayOfStrings.length, 80, bindings.kUnspecifiedArrayLength);
        for (int i0 = 0; i0 < multiArrayOfStrings.length; ++i0) {
          if (multiArrayOfStrings[i0] == null) {
            encoder1.encodeNullPointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, false);
          } else {
            var encoder2 = encoder1.encodePointerArray(multiArrayOfStrings[i0].length, bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i0, bindings.kUnspecifiedArrayLength);
            for (int i1 = 0; i1 < multiArrayOfStrings[i0].length; ++i1) {
              if (multiArrayOfStrings[i0][i1] == null) {
                encoder2.encodeNullPointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
              } else {
                var encoder3 = encoder2.encodePointerArray(multiArrayOfStrings[i0][i1].length, bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, bindings.kUnspecifiedArrayLength);
                for (int i2 = 0; i2 < multiArrayOfStrings[i0][i1].length; ++i2) {
                  encoder3.encodeString(multiArrayOfStrings[i0][i1][i2], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i2, false);
                }
              }
            }
          }
        }
      }
      fieldName = "arrayOfBools";
      encoder0.encodeBoolArray(arrayOfBools, 88, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "Foo("
           "x: $x" ", "
           "y: $y" ", "
           "a: $a" ", "
           "b: $b" ", "
           "c: $c" ", "
           "source: $source" ", "
           "bar: $bar" ", "
           "data: $data" ", "
           "extraBars: $extraBars" ", "
           "name: $name" ", "
           "inputStreams: $inputStreams" ", "
           "outputStreams: $outputStreams" ", "
           "arrayOfArrayOfBools: $arrayOfArrayOfBools" ", "
           "multiArrayOfStrings: $multiArrayOfStrings" ", "
           "arrayOfBools: $arrayOfBools" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class DefaultsTest extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(184, 0)
  ];
  int a0 = -12;
  int a1 = 12;
  int a2 = 1234;
  int a3 = 34567;
  bool a11 = true;
  bool a12 = false;
  int a4 = 123456;
  int a5 = 3456789012;
  int a6 = -111111111111;
  int a7 = 9999999999999999999;
  int a8 = 74565;
  int a9 = -74565;
  int a10 = 1234;
  double a13 = 123.25;
  double a14 = 1234567890.123;
  double a15 = 10000000000.0;
  double a16 = -1.2e+20;
  double a17 = 1.23e-20;
  List<int> a18 = null;
  String a19 = null;
  BarType a20 = new BarType(3);
  double a29 = double.INFINITY;
  sample_import_mojom.Point a21 = null;
  sample_import2_mojom.Thing a22 = new sample_import2_mojom.Thing();
  int a23 = 18446744073709551615;
  int a24 = 4886718345;
  int a25 = -4886718345;
  double a26 = double.INFINITY;
  double a27 = double.NEGATIVE_INFINITY;
  double a28 = double.NAN;
  double a30 = double.NEGATIVE_INFINITY;
  double a31 = double.NAN;

  DefaultsTest() : super(kVersions.last.size);

  DefaultsTest.init(
    int this.a0, 
    int this.a1, 
    int this.a2, 
    int this.a3, 
    bool this.a11, 
    bool this.a12, 
    int this.a4, 
    int this.a5, 
    int this.a6, 
    int this.a7, 
    int this.a8, 
    int this.a9, 
    int this.a10, 
    double this.a13, 
    double this.a14, 
    double this.a15, 
    double this.a16, 
    double this.a17, 
    List<int> this.a18, 
    String this.a19, 
    BarType this.a20, 
    double this.a29, 
    sample_import_mojom.Point this.a21, 
    sample_import2_mojom.Thing this.a22, 
    int this.a23, 
    int this.a24, 
    int this.a25, 
    double this.a26, 
    double this.a27, 
    double this.a28, 
    double this.a30, 
    double this.a31
  ) : super(kVersions.last.size);

  static DefaultsTest deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static DefaultsTest decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    DefaultsTest result = new DefaultsTest();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.a0 = decoder0.decodeInt8(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a1 = decoder0.decodeUint8(9);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a2 = decoder0.decodeInt16(10);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a3 = decoder0.decodeUint16(12);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a11 = decoder0.decodeBool(14, 0);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a12 = decoder0.decodeBool(14, 1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a4 = decoder0.decodeInt32(16);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a5 = decoder0.decodeUint32(20);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a6 = decoder0.decodeInt64(24);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a7 = decoder0.decodeUint64(32);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a8 = decoder0.decodeInt32(40);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a9 = decoder0.decodeInt32(44);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a10 = decoder0.decodeInt32(48);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a13 = decoder0.decodeFloat(52);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a14 = decoder0.decodeDouble(56);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a15 = decoder0.decodeDouble(64);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a16 = decoder0.decodeDouble(72);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a17 = decoder0.decodeDouble(80);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a18 = decoder0.decodeUint8Array(88, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a19 = decoder0.decodeString(96, false);
    }
    if (mainDataHeader.version >= 0) {
      
        result.a20 = BarType.decode(decoder0, 104);
        if (result.a20 == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable BarType.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      result.a29 = decoder0.decodeFloat(108);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(112, false);
      result.a21 = sample_import_mojom.Point.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(120, false);
      result.a22 = sample_import2_mojom.Thing.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a23 = decoder0.decodeUint64(128);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a24 = decoder0.decodeInt64(136);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a25 = decoder0.decodeInt64(144);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a26 = decoder0.decodeDouble(152);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a27 = decoder0.decodeDouble(160);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a28 = decoder0.decodeDouble(168);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a30 = decoder0.decodeFloat(176);
    }
    if (mainDataHeader.version >= 0) {
      
      result.a31 = decoder0.decodeFloat(180);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "DefaultsTest";
    String fieldName;
    try {
      fieldName = "a0";
      encoder0.encodeInt8(a0, 8);
      fieldName = "a1";
      encoder0.encodeUint8(a1, 9);
      fieldName = "a2";
      encoder0.encodeInt16(a2, 10);
      fieldName = "a3";
      encoder0.encodeUint16(a3, 12);
      fieldName = "a11";
      encoder0.encodeBool(a11, 14, 0);
      fieldName = "a12";
      encoder0.encodeBool(a12, 14, 1);
      fieldName = "a4";
      encoder0.encodeInt32(a4, 16);
      fieldName = "a5";
      encoder0.encodeUint32(a5, 20);
      fieldName = "a6";
      encoder0.encodeInt64(a6, 24);
      fieldName = "a7";
      encoder0.encodeUint64(a7, 32);
      fieldName = "a8";
      encoder0.encodeInt32(a8, 40);
      fieldName = "a9";
      encoder0.encodeInt32(a9, 44);
      fieldName = "a10";
      encoder0.encodeInt32(a10, 48);
      fieldName = "a13";
      encoder0.encodeFloat(a13, 52);
      fieldName = "a14";
      encoder0.encodeDouble(a14, 56);
      fieldName = "a15";
      encoder0.encodeDouble(a15, 64);
      fieldName = "a16";
      encoder0.encodeDouble(a16, 72);
      fieldName = "a17";
      encoder0.encodeDouble(a17, 80);
      fieldName = "a18";
      encoder0.encodeUint8Array(a18, 88, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
      fieldName = "a19";
      encoder0.encodeString(a19, 96, false);
      fieldName = "a20";
      encoder0.encodeEnum(a20, 104);
      fieldName = "a29";
      encoder0.encodeFloat(a29, 108);
      fieldName = "a21";
      encoder0.encodeStruct(a21, 112, false);
      fieldName = "a22";
      encoder0.encodeStruct(a22, 120, false);
      fieldName = "a23";
      encoder0.encodeUint64(a23, 128);
      fieldName = "a24";
      encoder0.encodeInt64(a24, 136);
      fieldName = "a25";
      encoder0.encodeInt64(a25, 144);
      fieldName = "a26";
      encoder0.encodeDouble(a26, 152);
      fieldName = "a27";
      encoder0.encodeDouble(a27, 160);
      fieldName = "a28";
      encoder0.encodeDouble(a28, 168);
      fieldName = "a30";
      encoder0.encodeFloat(a30, 176);
      fieldName = "a31";
      encoder0.encodeFloat(a31, 180);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "DefaultsTest("
           "a0: $a0" ", "
           "a1: $a1" ", "
           "a2: $a2" ", "
           "a3: $a3" ", "
           "a11: $a11" ", "
           "a12: $a12" ", "
           "a4: $a4" ", "
           "a5: $a5" ", "
           "a6: $a6" ", "
           "a7: $a7" ", "
           "a8: $a8" ", "
           "a9: $a9" ", "
           "a10: $a10" ", "
           "a13: $a13" ", "
           "a14: $a14" ", "
           "a15: $a15" ", "
           "a16: $a16" ", "
           "a17: $a17" ", "
           "a18: $a18" ", "
           "a19: $a19" ", "
           "a20: $a20" ", "
           "a29: $a29" ", "
           "a21: $a21" ", "
           "a22: $a22" ", "
           "a23: $a23" ", "
           "a24: $a24" ", "
           "a25: $a25" ", "
           "a26: $a26" ", "
           "a27: $a27" ", "
           "a28: $a28" ", "
           "a30: $a30" ", "
           "a31: $a31" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["a0"] = a0;
    map["a1"] = a1;
    map["a2"] = a2;
    map["a3"] = a3;
    map["a11"] = a11;
    map["a12"] = a12;
    map["a4"] = a4;
    map["a5"] = a5;
    map["a6"] = a6;
    map["a7"] = a7;
    map["a8"] = a8;
    map["a9"] = a9;
    map["a10"] = a10;
    map["a13"] = a13;
    map["a14"] = a14;
    map["a15"] = a15;
    map["a16"] = a16;
    map["a17"] = a17;
    map["a18"] = a18;
    map["a19"] = a19;
    map["a20"] = a20;
    map["a29"] = a29;
    map["a21"] = a21;
    map["a22"] = a22;
    map["a23"] = a23;
    map["a24"] = a24;
    map["a25"] = a25;
    map["a26"] = a26;
    map["a27"] = a27;
    map["a28"] = a28;
    map["a30"] = a30;
    map["a31"] = a31;
    return map;
  }
}


class StructWithHoleV1 extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  int v1 = 1;
  int v2 = 2;

  StructWithHoleV1() : super(kVersions.last.size);

  StructWithHoleV1.init(
    int this.v1, 
    int this.v2
  ) : super(kVersions.last.size);

  static StructWithHoleV1 deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithHoleV1 decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithHoleV1 result = new StructWithHoleV1();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.v1 = decoder0.decodeInt32(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.v2 = decoder0.decodeInt64(16);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithHoleV1";
    String fieldName;
    try {
      fieldName = "v1";
      encoder0.encodeInt32(v1, 8);
      fieldName = "v2";
      encoder0.encodeInt64(v2, 16);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithHoleV1("
           "v1: $v1" ", "
           "v2: $v2" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["v1"] = v1;
    map["v2"] = v2;
    return map;
  }
}


class StructWithHoleV2 extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  int v1 = 1;
  int v3 = 3;
  int v2 = 2;

  StructWithHoleV2() : super(kVersions.last.size);

  StructWithHoleV2.init(
    int this.v1, 
    int this.v3, 
    int this.v2
  ) : super(kVersions.last.size);

  static StructWithHoleV2 deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static StructWithHoleV2 decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    StructWithHoleV2 result = new StructWithHoleV2();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.v1 = decoder0.decodeInt32(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.v3 = decoder0.decodeInt32(12);
    }
    if (mainDataHeader.version >= 0) {
      
      result.v2 = decoder0.decodeInt64(16);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "StructWithHoleV2";
    String fieldName;
    try {
      fieldName = "v1";
      encoder0.encodeInt32(v1, 8);
      fieldName = "v3";
      encoder0.encodeInt32(v3, 12);
      fieldName = "v2";
      encoder0.encodeInt64(v2, 16);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "StructWithHoleV2("
           "v1: $v1" ", "
           "v3: $v3" ", "
           "v2: $v2" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["v1"] = v1;
    map["v3"] = v3;
    map["v2"] = v2;
    return map;
  }
}


class NonNullableMapStruct extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  Map<String, String> mapField = null;

  NonNullableMapStruct() : super(kVersions.last.size);

  NonNullableMapStruct.init(
    Map<String, String> this.mapField
  ) : super(kVersions.last.size);

  static NonNullableMapStruct deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static NonNullableMapStruct decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    NonNullableMapStruct result = new NonNullableMapStruct();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      {
        decoder1.decodeDataHeaderForMap();
        List<String> keys0;
        List<String> values0;
        {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize, false);
          {
            var si2 = decoder2.decodeDataHeaderForPointerArray(bindings.kUnspecifiedArrayLength);
            keys0 = new List<String>(si2.numElements);
            for (int i2 = 0; i2 < si2.numElements; ++i2) {
              
              keys0[i2] = decoder2.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i2, false);
            }
          }
        }
        {
          
          var decoder2 = decoder1.decodePointer(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize, false);
          {
            var si2 = decoder2.decodeDataHeaderForPointerArray(keys0.length);
            values0 = new List<String>(si2.numElements);
            for (int i2 = 0; i2 < si2.numElements; ++i2) {
              
              values0[i2] = decoder2.decodeString(bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i2, false);
            }
          }
        }
        result.mapField = new Map<String, String>.fromIterables(
            keys0, values0);
      }
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "NonNullableMapStruct";
    String fieldName;
    try {
      fieldName = "mapField";
      if (mapField == null) {
        encoder0.encodeNullPointer(8, false);
      } else {
        var encoder1 = encoder0.encoderForMap(8);
        var keys0 = mapField.keys.toList();
        var values0 = mapField.values.toList();
        
        {
          var encoder2 = encoder1.encodePointerArray(keys0.length, bindings.ArrayDataHeader.kHeaderSize, bindings.kUnspecifiedArrayLength);
          for (int i1 = 0; i1 < keys0.length; ++i1) {
            encoder2.encodeString(keys0[i1], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          }
        }
        
        {
          var encoder2 = encoder1.encodePointerArray(values0.length, bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize, bindings.kUnspecifiedArrayLength);
          for (int i1 = 0; i1 < values0.length; ++i1) {
            encoder2.encodeString(values0[i1], bindings.ArrayDataHeader.kHeaderSize + bindings.kPointerSize * i1, false);
          }
        }
      }
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "NonNullableMapStruct("
           "mapField: $mapField" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["mapField"] = mapField;
    return map;
  }
}


class _ServiceFrobinateParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  Foo foo = null;
  ServiceBazOptions baz = null;
  PortInterface port = null;

  _ServiceFrobinateParams() : super(kVersions.last.size);

  _ServiceFrobinateParams.init(
    Foo this.foo, 
    ServiceBazOptions this.baz, 
    PortInterface this.port
  ) : super(kVersions.last.size);

  static _ServiceFrobinateParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ServiceFrobinateParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ServiceFrobinateParams result = new _ServiceFrobinateParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.foo = Foo.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
        result.baz = ServiceBazOptions.decode(decoder0, 16);
        if (result.baz == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable ServiceBazOptions.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      result.port = decoder0.decodeServiceInterface(20, true, PortProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ServiceFrobinateParams";
    String fieldName;
    try {
      fieldName = "foo";
      encoder0.encodeStruct(foo, 8, true);
      fieldName = "baz";
      encoder0.encodeEnum(baz, 16);
      fieldName = "port";
      encoder0.encodeInterface(port, 20, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ServiceFrobinateParams("
           "foo: $foo" ", "
           "baz: $baz" ", "
           "port: $port" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class ServiceFrobinateResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int result = 0;

  ServiceFrobinateResponseParams() : super(kVersions.last.size);

  ServiceFrobinateResponseParams.init(
    int this.result
  ) : super(kVersions.last.size);

  static ServiceFrobinateResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static ServiceFrobinateResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    ServiceFrobinateResponseParams result = new ServiceFrobinateResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.result = decoder0.decodeInt32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "ServiceFrobinateResponseParams";
    String fieldName;
    try {
      fieldName = "result";
      encoder0.encodeInt32(result, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "ServiceFrobinateResponseParams("
           "result: $result" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["result"] = result;
    return map;
  }
}


class _ServiceGetPortParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  PortInterfaceRequest port = null;

  _ServiceGetPortParams() : super(kVersions.last.size);

  _ServiceGetPortParams.init(
    PortInterfaceRequest this.port
  ) : super(kVersions.last.size);

  static _ServiceGetPortParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _ServiceGetPortParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _ServiceGetPortParams result = new _ServiceGetPortParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.port = decoder0.decodeInterfaceRequest(8, false, PortStub.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_ServiceGetPortParams";
    String fieldName;
    try {
      fieldName = "port";
      encoder0.encodeInterfaceRequest(port, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_ServiceGetPortParams("
           "port: $port" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _PortPostMessageParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  String messageText = null;
  PortInterface port = null;

  _PortPostMessageParams() : super(kVersions.last.size);

  _PortPostMessageParams.init(
    String this.messageText, 
    PortInterface this.port
  ) : super(kVersions.last.size);

  static _PortPostMessageParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _PortPostMessageParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _PortPostMessageParams result = new _PortPostMessageParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.messageText = decoder0.decodeString(8, false);
    }
    if (mainDataHeader.version >= 0) {
      
      result.port = decoder0.decodeServiceInterface(16, false, PortProxy.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_PortPostMessageParams";
    String fieldName;
    try {
      fieldName = "messageText";
      encoder0.encodeString(messageText, 8, false);
      fieldName = "port";
      encoder0.encodeInterface(port, 16, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_PortPostMessageParams("
           "messageText: $messageText" ", "
           "port: $port" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}

const int _serviceMethodFrobinateName = 0;
const int _serviceMethodGetPortName = 1;
  
class ServiceBazOptions extends bindings.MojoEnum {
  static const ServiceBazOptions regular = const ServiceBazOptions._(0);
  static const ServiceBazOptions extra = const ServiceBazOptions._(1);

  const ServiceBazOptions._(int v) : super(v);

  static const Map<String, ServiceBazOptions> valuesMap = const {
    "regular": regular,
    "extra": extra,
  };
  static const List<ServiceBazOptions> values = const [
    regular,
    extra,
  ];

  static ServiceBazOptions valueOf(String name) => valuesMap[name];

  factory ServiceBazOptions(int v) {
    switch (v) {
      case 0:
        return ServiceBazOptions.regular;
      case 1:
        return ServiceBazOptions.extra;
      default:
        return null;
    }
  }

  static ServiceBazOptions decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    ServiceBazOptions result = new ServiceBazOptions(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum ServiceBazOptions.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case regular:
        return 'ServiceBazOptions.regular';
      case extra:
        return 'ServiceBazOptions.extra';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}

class _ServiceServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class Service {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _ServiceServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static ServiceProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    ServiceProxy p = new ServiceProxy.unbound();
    String name = serviceName ?? Service.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void frobinate(Foo foo,ServiceBazOptions baz,PortInterface port,void callback(int result));
  void getPort(PortInterfaceRequest port);
  static const int kFavoriteBaz = 1;
}

abstract class ServiceInterface
    implements bindings.MojoInterface<Service>,
               Service {
  factory ServiceInterface([Service impl]) =>
      new ServiceStub.unbound(impl);

  factory ServiceInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [Service impl]) =>
      new ServiceStub.fromEndpoint(endpoint, impl);

  factory ServiceInterface.fromMock(
      Service mock) =>
      new ServiceProxy.fromMock(mock);
}

abstract class ServiceInterfaceRequest
    implements bindings.MojoInterface<Service>,
               Service {
  factory ServiceInterfaceRequest() =>
      new ServiceProxy.unbound();
}

class _ServiceProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<Service> {
  Service impl;

  _ServiceProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _ServiceProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _ServiceProxyControl.unbound() : super.unbound();

  String get serviceName => Service.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _serviceMethodFrobinateName:
        var r = ServiceFrobinateResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.result );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ServiceProxyControl($superString)";
  }
}

class ServiceProxy
    extends bindings.Proxy<Service>
    implements Service,
               ServiceInterface,
               ServiceInterfaceRequest {
  ServiceProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _ServiceProxyControl.fromEndpoint(endpoint));

  ServiceProxy.fromHandle(core.MojoHandle handle)
      : super(new _ServiceProxyControl.fromHandle(handle));

  ServiceProxy.unbound()
      : super(new _ServiceProxyControl.unbound());

  factory ServiceProxy.fromMock(Service mock) {
    ServiceProxy newMockedProxy =
        new ServiceProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static ServiceProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ServiceProxy"));
    return new ServiceProxy.fromEndpoint(endpoint);
  }


  void frobinate(Foo foo,ServiceBazOptions baz,PortInterface port,void callback(int result)) {
    if (impl != null) {
      impl.frobinate(foo,baz,port,callback);
      return;
    }
    var params = new _ServiceFrobinateParams();
    params.foo = foo;
    params.baz = baz;
    params.port = port;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((int result) {
        z.bindCallback(() {
          callback(result);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _serviceMethodFrobinateName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void getPort(PortInterfaceRequest port) {
    if (impl != null) {
      impl.getPort(port);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _ServiceGetPortParams();
    params.port = port;
    ctrl.sendMessage(params,
        _serviceMethodGetPortName);
  }
}

class _ServiceStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<Service> {
  Service _impl;

  _ServiceStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Service impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _ServiceStubControl.fromHandle(
      core.MojoHandle handle, [Service impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _ServiceStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => Service.serviceName;


  Function _serviceFrobinateResponseParamsResponder(
      int requestId) {
  return (int result) {
      var result = new ServiceFrobinateResponseParams();
      result.result = result;
      sendResponse(buildResponseWithId(
          result,
          _serviceMethodFrobinateName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _serviceMethodFrobinateName:
        var params = _ServiceFrobinateParams.deserialize(
            message.payload);
        _impl.frobinate(params.foo, params.baz, params.port, _serviceFrobinateResponseParamsResponder(message.header.requestId));
        break;
      case _serviceMethodGetPortName:
        var params = _ServiceGetPortParams.deserialize(
            message.payload);
        _impl.getPort(params.port);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  Service get impl => _impl;
  set impl(Service d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_ServiceStubControl($superString)";
  }

  int get version => 0;
}

class ServiceStub
    extends bindings.Stub<Service>
    implements Service,
               ServiceInterface,
               ServiceInterfaceRequest {
  ServiceStub.unbound([Service impl])
      : super(new _ServiceStubControl.unbound(impl));

  ServiceStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Service impl])
      : super(new _ServiceStubControl.fromEndpoint(endpoint, impl));

  ServiceStub.fromHandle(
      core.MojoHandle handle, [Service impl])
      : super(new _ServiceStubControl.fromHandle(handle, impl));

  static ServiceStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For ServiceStub"));
    return new ServiceStub.fromEndpoint(endpoint);
  }


  void frobinate(Foo foo,ServiceBazOptions baz,PortInterface port,void callback(int result)) {
    return impl.frobinate(foo,baz,port,callback);
  }
  void getPort(PortInterfaceRequest port) {
    return impl.getPort(port);
  }
}

const int _portMethodPostMessageName = 0;

class _PortServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class Port {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _PortServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static PortProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    PortProxy p = new PortProxy.unbound();
    String name = serviceName ?? Port.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void postMessage(String messageText, PortInterface port);
}

abstract class PortInterface
    implements bindings.MojoInterface<Port>,
               Port {
  factory PortInterface([Port impl]) =>
      new PortStub.unbound(impl);

  factory PortInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [Port impl]) =>
      new PortStub.fromEndpoint(endpoint, impl);

  factory PortInterface.fromMock(
      Port mock) =>
      new PortProxy.fromMock(mock);
}

abstract class PortInterfaceRequest
    implements bindings.MojoInterface<Port>,
               Port {
  factory PortInterfaceRequest() =>
      new PortProxy.unbound();
}

class _PortProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<Port> {
  Port impl;

  _PortProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _PortProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _PortProxyControl.unbound() : super.unbound();

  String get serviceName => Port.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_PortProxyControl($superString)";
  }
}

class PortProxy
    extends bindings.Proxy<Port>
    implements Port,
               PortInterface,
               PortInterfaceRequest {
  PortProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _PortProxyControl.fromEndpoint(endpoint));

  PortProxy.fromHandle(core.MojoHandle handle)
      : super(new _PortProxyControl.fromHandle(handle));

  PortProxy.unbound()
      : super(new _PortProxyControl.unbound());

  factory PortProxy.fromMock(Port mock) {
    PortProxy newMockedProxy =
        new PortProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static PortProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For PortProxy"));
    return new PortProxy.fromEndpoint(endpoint);
  }


  void postMessage(String messageText, PortInterface port) {
    if (impl != null) {
      impl.postMessage(messageText, port);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _PortPostMessageParams();
    params.messageText = messageText;
    params.port = port;
    ctrl.sendMessage(params,
        _portMethodPostMessageName);
  }
}

class _PortStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<Port> {
  Port _impl;

  _PortStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Port impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _PortStubControl.fromHandle(
      core.MojoHandle handle, [Port impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _PortStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => Port.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _portMethodPostMessageName:
        var params = _PortPostMessageParams.deserialize(
            message.payload);
        _impl.postMessage(params.messageText, params.port);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  Port get impl => _impl;
  set impl(Port d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_PortStubControl($superString)";
  }

  int get version => 0;
}

class PortStub
    extends bindings.Stub<Port>
    implements Port,
               PortInterface,
               PortInterfaceRequest {
  PortStub.unbound([Port impl])
      : super(new _PortStubControl.unbound(impl));

  PortStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [Port impl])
      : super(new _PortStubControl.fromEndpoint(endpoint, impl));

  PortStub.fromHandle(
      core.MojoHandle handle, [Port impl])
      : super(new _PortStubControl.fromHandle(handle, impl));

  static PortStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For PortStub"));
    return new PortStub.fromEndpoint(endpoint);
  }


  void postMessage(String messageText, PortInterface port) {
    return impl.postMessage(messageText, port);
  }
}


mojom_types.RuntimeTypeInfo getRuntimeTypeInfo() => _runtimeTypeInfo ??
    _initRuntimeTypeInfo();

Map<String, mojom_types.UserDefinedType> getAllMojomTypeDefinitions() {
  return getRuntimeTypeInfo().typeMap;
}

var _runtimeTypeInfo;
mojom_types.RuntimeTypeInfo  _initRuntimeTypeInfo() {
  // serializedRuntimeTypeInfo contains the bytes of the Mojo serialization of
  // a mojom_types.RuntimeTypeInfo struct describing the Mojom types in this
  // file. The string contains the base64 encoding of the gzip-compressed bytes.
  var serializedRuntimeTypeInfo = "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";

  // Deserialize RuntimeTypeInfo
  var bytes = BASE64.decode(serializedRuntimeTypeInfo);
  var unzippedBytes = new ZLibDecoder().convert(bytes);
  var bdata = new ByteData.view(unzippedBytes.buffer);
  var message = new bindings.Message(bdata, null, unzippedBytes.length, 0);
  _runtimeTypeInfo = mojom_types.RuntimeTypeInfo.deserialize(message);
  sample_import_mojom.getAllMojomTypeDefinitions()
      .forEach((String s, mojom_types.UserDefinedType udt) {
          _runtimeTypeInfo.typeMap[s] = udt;
      });

  sample_import2_mojom.getAllMojomTypeDefinitions()
      .forEach((String s, mojom_types.UserDefinedType udt) {
          _runtimeTypeInfo.typeMap[s] = udt;
      });

  return _runtimeTypeInfo;
}
