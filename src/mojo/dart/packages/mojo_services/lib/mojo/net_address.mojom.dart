// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library net_address_mojom;
import 'package:mojo/bindings.dart' as bindings;


class NetAddressFamily extends bindings.MojoEnum {
  static const NetAddressFamily unspecified = const NetAddressFamily._(0);
  static const NetAddressFamily ipv4 = const NetAddressFamily._(1);
  static const NetAddressFamily ipv6 = const NetAddressFamily._(2);

  const NetAddressFamily._(int v) : super(v);

  static const Map<String, NetAddressFamily> valuesMap = const {
    "unspecified": unspecified,
    "ipv4": ipv4,
    "ipv6": ipv6,
  };
  static const List<NetAddressFamily> values = const [
    unspecified,
    ipv4,
    ipv6,
  ];

  static NetAddressFamily valueOf(String name) => valuesMap[name];

  factory NetAddressFamily(int v) {
    switch (v) {
      case 0:
        return NetAddressFamily.unspecified;
      case 1:
        return NetAddressFamily.ipv4;
      case 2:
        return NetAddressFamily.ipv6;
      default:
        return null;
    }
  }

  static NetAddressFamily decode(bindings.Decoder decoder0, int offset) {
    int v = decoder0.decodeUint32(offset);
    NetAddressFamily result = new NetAddressFamily(v);
    if (result == null) {
      throw new bindings.MojoCodecError(
          'Bad value $v for enum NetAddressFamily.');
    }
    return result;
  }

  String toString() {
    switch(this) {
      case unspecified:
        return 'NetAddressFamily.unspecified';
      case ipv4:
        return 'NetAddressFamily.ipv4';
      case ipv6:
        return 'NetAddressFamily.ipv6';
      default:
        return null;
    }
  }

  int toJson() => mojoEnumValue;
}



class NetAddressIPv4 extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  int port = 0;
  List<int> addr = null;

  NetAddressIPv4() : super(kVersions.last.size);

  NetAddressIPv4.init(
    int this.port, 
    List<int> this.addr
  ) : super(kVersions.last.size);

  static NetAddressIPv4 deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static NetAddressIPv4 decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    NetAddressIPv4 result = new NetAddressIPv4();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.port = decoder0.decodeUint16(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.addr = decoder0.decodeUint8Array(16, bindings.kNothingNullable, 4);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "NetAddressIPv4";
    String fieldName;
    try {
      fieldName = "port";
      encoder0.encodeUint16(port, 8);
      fieldName = "addr";
      encoder0.encodeUint8Array(addr, 16, bindings.kNothingNullable, 4);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "NetAddressIPv4("
           "port: $port" ", "
           "addr: $addr" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["port"] = port;
    map["addr"] = addr;
    return map;
  }
}


class NetAddressIPv6 extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  int port = 0;
  List<int> addr = null;

  NetAddressIPv6() : super(kVersions.last.size);

  NetAddressIPv6.init(
    int this.port, 
    List<int> this.addr
  ) : super(kVersions.last.size);

  static NetAddressIPv6 deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static NetAddressIPv6 decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    NetAddressIPv6 result = new NetAddressIPv6();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.port = decoder0.decodeUint16(8);
    }
    if (mainDataHeader.version >= 0) {
      
      result.addr = decoder0.decodeUint8Array(16, bindings.kNothingNullable, 16);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "NetAddressIPv6";
    String fieldName;
    try {
      fieldName = "port";
      encoder0.encodeUint16(port, 8);
      fieldName = "addr";
      encoder0.encodeUint8Array(addr, 16, bindings.kNothingNullable, 16);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "NetAddressIPv6("
           "port: $port" ", "
           "addr: $addr" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["port"] = port;
    map["addr"] = addr;
    return map;
  }
}


class NetAddress extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  NetAddressFamily family = new NetAddressFamily(0);
  NetAddressIPv4 ipv4 = null;
  NetAddressIPv6 ipv6 = null;

  NetAddress() : super(kVersions.last.size);

  NetAddress.init(
    NetAddressFamily this.family, 
    NetAddressIPv4 this.ipv4, 
    NetAddressIPv6 this.ipv6
  ) : super(kVersions.last.size);

  static NetAddress deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static NetAddress decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    NetAddress result = new NetAddress();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
        result.family = NetAddressFamily.decode(decoder0, 8);
        if (result.family == null) {
          throw new bindings.MojoCodecError(
            'Trying to decode null union for non-nullable NetAddressFamily.');
        }
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.ipv4 = NetAddressIPv4.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(24, true);
      result.ipv6 = NetAddressIPv6.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "NetAddress";
    String fieldName;
    try {
      fieldName = "family";
      encoder0.encodeEnum(family, 8);
      fieldName = "ipv4";
      encoder0.encodeStruct(ipv4, 16, true);
      fieldName = "ipv6";
      encoder0.encodeStruct(ipv6, 24, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "NetAddress("
           "family: $family" ", "
           "ipv4: $ipv4" ", "
           "ipv6: $ipv6" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["family"] = family;
    map["ipv4"] = ipv4;
    map["ipv6"] = ipv6;
    return map;
  }
}



