// WARNING: DO NOT EDIT. This file was generated by a program.
// See $MOJO_SDK/tools/bindings/mojom_bindings_generator.py.

library udp_socket_mojom;
import 'dart:async';
import 'package:mojo/bindings.dart' as bindings;
import 'package:mojo/core.dart' as core;
import 'package:mojo/mojo/bindings/types/service_describer.mojom.dart' as service_describer;
import 'package:mojo/mojo/network_error.mojom.dart' as network_error_mojom;
import 'package:mojo_services/mojo/net_address.mojom.dart' as net_address_mojom;



class _UdpSocketAllowAddressReuseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(8, 0)
  ];

  _UdpSocketAllowAddressReuseParams() : super(kVersions.last.size);

  _UdpSocketAllowAddressReuseParams.init(
  ) : super(kVersions.last.size);

  static _UdpSocketAllowAddressReuseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _UdpSocketAllowAddressReuseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _UdpSocketAllowAddressReuseParams result = new _UdpSocketAllowAddressReuseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    return result;
  }

  void encode(bindings.Encoder encoder) {
    encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_UdpSocketAllowAddressReuseParams";
    String fieldName;
    try {
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_UdpSocketAllowAddressReuseParams("")";
  }

  Map toJson() {
    Map map = new Map();
    return map;
  }
}


class UdpSocketAllowAddressReuseResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  network_error_mojom.NetworkError result = null;

  UdpSocketAllowAddressReuseResponseParams() : super(kVersions.last.size);

  UdpSocketAllowAddressReuseResponseParams.init(
    network_error_mojom.NetworkError this.result
  ) : super(kVersions.last.size);

  static UdpSocketAllowAddressReuseResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static UdpSocketAllowAddressReuseResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    UdpSocketAllowAddressReuseResponseParams result = new UdpSocketAllowAddressReuseResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.result = network_error_mojom.NetworkError.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "UdpSocketAllowAddressReuseResponseParams";
    String fieldName;
    try {
      fieldName = "result";
      encoder0.encodeStruct(result, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "UdpSocketAllowAddressReuseResponseParams("
           "result: $result" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["result"] = result;
    return map;
  }
}


class _UdpSocketBindParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  net_address_mojom.NetAddress addr = null;

  _UdpSocketBindParams() : super(kVersions.last.size);

  _UdpSocketBindParams.init(
    net_address_mojom.NetAddress this.addr
  ) : super(kVersions.last.size);

  static _UdpSocketBindParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _UdpSocketBindParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _UdpSocketBindParams result = new _UdpSocketBindParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.addr = net_address_mojom.NetAddress.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_UdpSocketBindParams";
    String fieldName;
    try {
      fieldName = "addr";
      encoder0.encodeStruct(addr, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_UdpSocketBindParams("
           "addr: $addr" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["addr"] = addr;
    return map;
  }
}


class UdpSocketBindResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  network_error_mojom.NetworkError result = null;
  net_address_mojom.NetAddress boundAddr = null;
  UdpSocketReceiverInterfaceRequest receiver = null;

  UdpSocketBindResponseParams() : super(kVersions.last.size);

  UdpSocketBindResponseParams.init(
    network_error_mojom.NetworkError this.result, 
    net_address_mojom.NetAddress this.boundAddr, 
    UdpSocketReceiverInterfaceRequest this.receiver
  ) : super(kVersions.last.size);

  static UdpSocketBindResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static UdpSocketBindResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    UdpSocketBindResponseParams result = new UdpSocketBindResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.result = network_error_mojom.NetworkError.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.boundAddr = net_address_mojom.NetAddress.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.receiver = decoder0.decodeInterfaceRequest(24, true, UdpSocketReceiverStub.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "UdpSocketBindResponseParams";
    String fieldName;
    try {
      fieldName = "result";
      encoder0.encodeStruct(result, 8, false);
      fieldName = "boundAddr";
      encoder0.encodeStruct(boundAddr, 16, true);
      fieldName = "receiver";
      encoder0.encodeInterfaceRequest(receiver, 24, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "UdpSocketBindResponseParams("
           "result: $result" ", "
           "boundAddr: $boundAddr" ", "
           "receiver: $receiver" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _UdpSocketConnectParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  net_address_mojom.NetAddress remoteAddr = null;

  _UdpSocketConnectParams() : super(kVersions.last.size);

  _UdpSocketConnectParams.init(
    net_address_mojom.NetAddress this.remoteAddr
  ) : super(kVersions.last.size);

  static _UdpSocketConnectParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _UdpSocketConnectParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _UdpSocketConnectParams result = new _UdpSocketConnectParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.remoteAddr = net_address_mojom.NetAddress.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_UdpSocketConnectParams";
    String fieldName;
    try {
      fieldName = "remoteAddr";
      encoder0.encodeStruct(remoteAddr, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_UdpSocketConnectParams("
           "remoteAddr: $remoteAddr" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["remoteAddr"] = remoteAddr;
    return map;
  }
}


class UdpSocketConnectResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  network_error_mojom.NetworkError result = null;
  net_address_mojom.NetAddress localAddr = null;
  UdpSocketReceiverInterfaceRequest receiver = null;

  UdpSocketConnectResponseParams() : super(kVersions.last.size);

  UdpSocketConnectResponseParams.init(
    network_error_mojom.NetworkError this.result, 
    net_address_mojom.NetAddress this.localAddr, 
    UdpSocketReceiverInterfaceRequest this.receiver
  ) : super(kVersions.last.size);

  static UdpSocketConnectResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static UdpSocketConnectResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    UdpSocketConnectResponseParams result = new UdpSocketConnectResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.result = network_error_mojom.NetworkError.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.localAddr = net_address_mojom.NetAddress.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.receiver = decoder0.decodeInterfaceRequest(24, true, UdpSocketReceiverStub.newFromEndpoint);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "UdpSocketConnectResponseParams";
    String fieldName;
    try {
      fieldName = "result";
      encoder0.encodeStruct(result, 8, false);
      fieldName = "localAddr";
      encoder0.encodeStruct(localAddr, 16, true);
      fieldName = "receiver";
      encoder0.encodeInterfaceRequest(receiver, 24, true);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "UdpSocketConnectResponseParams("
           "result: $result" ", "
           "localAddr: $localAddr" ", "
           "receiver: $receiver" ")";
  }

  Map toJson() {
    throw new bindings.MojoCodecError(
        'Object containing handles cannot be encoded to JSON.');
  }
}


class _UdpSocketSetSendBufferSizeParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int size = 0;

  _UdpSocketSetSendBufferSizeParams() : super(kVersions.last.size);

  _UdpSocketSetSendBufferSizeParams.init(
    int this.size
  ) : super(kVersions.last.size);

  static _UdpSocketSetSendBufferSizeParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _UdpSocketSetSendBufferSizeParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _UdpSocketSetSendBufferSizeParams result = new _UdpSocketSetSendBufferSizeParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.size = decoder0.decodeUint32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_UdpSocketSetSendBufferSizeParams";
    String fieldName;
    try {
      fieldName = "size";
      encoder0.encodeUint32(size, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_UdpSocketSetSendBufferSizeParams("
           "size: $size" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["size"] = size;
    return map;
  }
}


class UdpSocketSetSendBufferSizeResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  network_error_mojom.NetworkError result = null;

  UdpSocketSetSendBufferSizeResponseParams() : super(kVersions.last.size);

  UdpSocketSetSendBufferSizeResponseParams.init(
    network_error_mojom.NetworkError this.result
  ) : super(kVersions.last.size);

  static UdpSocketSetSendBufferSizeResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static UdpSocketSetSendBufferSizeResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    UdpSocketSetSendBufferSizeResponseParams result = new UdpSocketSetSendBufferSizeResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.result = network_error_mojom.NetworkError.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "UdpSocketSetSendBufferSizeResponseParams";
    String fieldName;
    try {
      fieldName = "result";
      encoder0.encodeStruct(result, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "UdpSocketSetSendBufferSizeResponseParams("
           "result: $result" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["result"] = result;
    return map;
  }
}


class _UdpSocketSetReceiveBufferSizeParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int size = 0;

  _UdpSocketSetReceiveBufferSizeParams() : super(kVersions.last.size);

  _UdpSocketSetReceiveBufferSizeParams.init(
    int this.size
  ) : super(kVersions.last.size);

  static _UdpSocketSetReceiveBufferSizeParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _UdpSocketSetReceiveBufferSizeParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _UdpSocketSetReceiveBufferSizeParams result = new _UdpSocketSetReceiveBufferSizeParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.size = decoder0.decodeUint32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_UdpSocketSetReceiveBufferSizeParams";
    String fieldName;
    try {
      fieldName = "size";
      encoder0.encodeUint32(size, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_UdpSocketSetReceiveBufferSizeParams("
           "size: $size" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["size"] = size;
    return map;
  }
}


class UdpSocketSetReceiveBufferSizeResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  network_error_mojom.NetworkError result = null;

  UdpSocketSetReceiveBufferSizeResponseParams() : super(kVersions.last.size);

  UdpSocketSetReceiveBufferSizeResponseParams.init(
    network_error_mojom.NetworkError this.result
  ) : super(kVersions.last.size);

  static UdpSocketSetReceiveBufferSizeResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static UdpSocketSetReceiveBufferSizeResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    UdpSocketSetReceiveBufferSizeResponseParams result = new UdpSocketSetReceiveBufferSizeResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.result = network_error_mojom.NetworkError.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "UdpSocketSetReceiveBufferSizeResponseParams";
    String fieldName;
    try {
      fieldName = "result";
      encoder0.encodeStruct(result, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "UdpSocketSetReceiveBufferSizeResponseParams("
           "result: $result" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["result"] = result;
    return map;
  }
}


class _UdpSocketNegotiateMaxPendingSendRequestsParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int requestedSize = 0;

  _UdpSocketNegotiateMaxPendingSendRequestsParams() : super(kVersions.last.size);

  _UdpSocketNegotiateMaxPendingSendRequestsParams.init(
    int this.requestedSize
  ) : super(kVersions.last.size);

  static _UdpSocketNegotiateMaxPendingSendRequestsParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _UdpSocketNegotiateMaxPendingSendRequestsParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _UdpSocketNegotiateMaxPendingSendRequestsParams result = new _UdpSocketNegotiateMaxPendingSendRequestsParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.requestedSize = decoder0.decodeUint32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_UdpSocketNegotiateMaxPendingSendRequestsParams";
    String fieldName;
    try {
      fieldName = "requestedSize";
      encoder0.encodeUint32(requestedSize, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_UdpSocketNegotiateMaxPendingSendRequestsParams("
           "requestedSize: $requestedSize" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["requestedSize"] = requestedSize;
    return map;
  }
}


class UdpSocketNegotiateMaxPendingSendRequestsResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int actualSize = 0;

  UdpSocketNegotiateMaxPendingSendRequestsResponseParams() : super(kVersions.last.size);

  UdpSocketNegotiateMaxPendingSendRequestsResponseParams.init(
    int this.actualSize
  ) : super(kVersions.last.size);

  static UdpSocketNegotiateMaxPendingSendRequestsResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static UdpSocketNegotiateMaxPendingSendRequestsResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    UdpSocketNegotiateMaxPendingSendRequestsResponseParams result = new UdpSocketNegotiateMaxPendingSendRequestsResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.actualSize = decoder0.decodeUint32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "UdpSocketNegotiateMaxPendingSendRequestsResponseParams";
    String fieldName;
    try {
      fieldName = "actualSize";
      encoder0.encodeUint32(actualSize, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "UdpSocketNegotiateMaxPendingSendRequestsResponseParams("
           "actualSize: $actualSize" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["actualSize"] = actualSize;
    return map;
  }
}


class _UdpSocketReceiveMoreParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  int datagramNumber = 0;

  _UdpSocketReceiveMoreParams() : super(kVersions.last.size);

  _UdpSocketReceiveMoreParams.init(
    int this.datagramNumber
  ) : super(kVersions.last.size);

  static _UdpSocketReceiveMoreParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _UdpSocketReceiveMoreParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _UdpSocketReceiveMoreParams result = new _UdpSocketReceiveMoreParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      result.datagramNumber = decoder0.decodeUint32(8);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_UdpSocketReceiveMoreParams";
    String fieldName;
    try {
      fieldName = "datagramNumber";
      encoder0.encodeUint32(datagramNumber, 8);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_UdpSocketReceiveMoreParams("
           "datagramNumber: $datagramNumber" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["datagramNumber"] = datagramNumber;
    return map;
  }
}


class _UdpSocketSendToParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(24, 0)
  ];
  net_address_mojom.NetAddress destAddr = null;
  List<int> data = null;

  _UdpSocketSendToParams() : super(kVersions.last.size);

  _UdpSocketSendToParams.init(
    net_address_mojom.NetAddress this.destAddr, 
    List<int> this.data
  ) : super(kVersions.last.size);

  static _UdpSocketSendToParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _UdpSocketSendToParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _UdpSocketSendToParams result = new _UdpSocketSendToParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, true);
      result.destAddr = net_address_mojom.NetAddress.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.data = decoder0.decodeUint8Array(16, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_UdpSocketSendToParams";
    String fieldName;
    try {
      fieldName = "destAddr";
      encoder0.encodeStruct(destAddr, 8, true);
      fieldName = "data";
      encoder0.encodeUint8Array(data, 16, bindings.kNothingNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_UdpSocketSendToParams("
           "destAddr: $destAddr" ", "
           "data: $data" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["destAddr"] = destAddr;
    map["data"] = data;
    return map;
  }
}


class UdpSocketSendToResponseParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(16, 0)
  ];
  network_error_mojom.NetworkError result = null;

  UdpSocketSendToResponseParams() : super(kVersions.last.size);

  UdpSocketSendToResponseParams.init(
    network_error_mojom.NetworkError this.result
  ) : super(kVersions.last.size);

  static UdpSocketSendToResponseParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static UdpSocketSendToResponseParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    UdpSocketSendToResponseParams result = new UdpSocketSendToResponseParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.result = network_error_mojom.NetworkError.decode(decoder1);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "UdpSocketSendToResponseParams";
    String fieldName;
    try {
      fieldName = "result";
      encoder0.encodeStruct(result, 8, false);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "UdpSocketSendToResponseParams("
           "result: $result" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["result"] = result;
    return map;
  }
}


class _UdpSocketReceiverOnReceivedParams extends bindings.Struct {
  static const List<bindings.StructDataHeader> kVersions = const [
    const bindings.StructDataHeader(32, 0)
  ];
  network_error_mojom.NetworkError result = null;
  net_address_mojom.NetAddress srcAddr = null;
  List<int> data = null;

  _UdpSocketReceiverOnReceivedParams() : super(kVersions.last.size);

  _UdpSocketReceiverOnReceivedParams.init(
    network_error_mojom.NetworkError this.result, 
    net_address_mojom.NetAddress this.srcAddr, 
    List<int> this.data
  ) : super(kVersions.last.size);

  static _UdpSocketReceiverOnReceivedParams deserialize(bindings.Message message) =>
      bindings.Struct.deserialize(decode, message);

  static _UdpSocketReceiverOnReceivedParams decode(bindings.Decoder decoder0) {
    if (decoder0 == null) {
      return null;
    }
    _UdpSocketReceiverOnReceivedParams result = new _UdpSocketReceiverOnReceivedParams();

    var mainDataHeader = bindings.Struct.checkVersion(decoder0, kVersions);
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(8, false);
      result.result = network_error_mojom.NetworkError.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      var decoder1 = decoder0.decodePointer(16, true);
      result.srcAddr = net_address_mojom.NetAddress.decode(decoder1);
    }
    if (mainDataHeader.version >= 0) {
      
      result.data = decoder0.decodeUint8Array(24, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    }
    return result;
  }

  void encode(bindings.Encoder encoder) {
    var encoder0 = encoder.getStructEncoderAtOffset(kVersions.last);
    const String structName = "_UdpSocketReceiverOnReceivedParams";
    String fieldName;
    try {
      fieldName = "result";
      encoder0.encodeStruct(result, 8, false);
      fieldName = "srcAddr";
      encoder0.encodeStruct(srcAddr, 16, true);
      fieldName = "data";
      encoder0.encodeUint8Array(data, 24, bindings.kArrayNullable, bindings.kUnspecifiedArrayLength);
    } on bindings.MojoCodecError catch(e) {
      bindings.Struct.fixErrorMessage(e, fieldName, structName);
      rethrow;
    }
  }

  String toString() {
    return "_UdpSocketReceiverOnReceivedParams("
           "result: $result" ", "
           "srcAddr: $srcAddr" ", "
           "data: $data" ")";
  }

  Map toJson() {
    Map map = new Map();
    map["result"] = result;
    map["srcAddr"] = srcAddr;
    map["data"] = data;
    return map;
  }
}

const int _udpSocketMethodAllowAddressReuseName = 0;
const int _udpSocketMethodBindName = 1;
const int _udpSocketMethodConnectName = 2;
const int _udpSocketMethodSetSendBufferSizeName = 3;
const int _udpSocketMethodSetReceiveBufferSizeName = 4;
const int _udpSocketMethodNegotiateMaxPendingSendRequestsName = 5;
const int _udpSocketMethodReceiveMoreName = 6;
const int _udpSocketMethodSendToName = 7;

class _UdpSocketServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class UdpSocket {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _UdpSocketServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static UdpSocketProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    UdpSocketProxy p = new UdpSocketProxy.unbound();
    String name = serviceName ?? UdpSocket.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void allowAddressReuse(void callback(network_error_mojom.NetworkError result));
  void bind(net_address_mojom.NetAddress addr,void callback(network_error_mojom.NetworkError result, net_address_mojom.NetAddress boundAddr, UdpSocketReceiverInterfaceRequest receiver));
  void connect(net_address_mojom.NetAddress remoteAddr,void callback(network_error_mojom.NetworkError result, net_address_mojom.NetAddress localAddr, UdpSocketReceiverInterfaceRequest receiver));
  void setSendBufferSize(int size,void callback(network_error_mojom.NetworkError result));
  void setReceiveBufferSize(int size,void callback(network_error_mojom.NetworkError result));
  void negotiateMaxPendingSendRequests(int requestedSize,void callback(int actualSize));
  void receiveMore(int datagramNumber);
  void sendTo(net_address_mojom.NetAddress destAddr,List<int> data,void callback(network_error_mojom.NetworkError result));
}

abstract class UdpSocketInterface
    implements bindings.MojoInterface<UdpSocket>,
               UdpSocket {
  factory UdpSocketInterface([UdpSocket impl]) =>
      new UdpSocketStub.unbound(impl);

  factory UdpSocketInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [UdpSocket impl]) =>
      new UdpSocketStub.fromEndpoint(endpoint, impl);

  factory UdpSocketInterface.fromMock(
      UdpSocket mock) =>
      new UdpSocketProxy.fromMock(mock);
}

abstract class UdpSocketInterfaceRequest
    implements bindings.MojoInterface<UdpSocket>,
               UdpSocket {
  factory UdpSocketInterfaceRequest() =>
      new UdpSocketProxy.unbound();
}

class _UdpSocketProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<UdpSocket> {
  UdpSocket impl;

  _UdpSocketProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _UdpSocketProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _UdpSocketProxyControl.unbound() : super.unbound();

  String get serviceName => UdpSocket.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      case _udpSocketMethodAllowAddressReuseName:
        var r = UdpSocketAllowAddressReuseResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.result );
        break;
      case _udpSocketMethodBindName:
        var r = UdpSocketBindResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.result , r.boundAddr , r.receiver );
        break;
      case _udpSocketMethodConnectName:
        var r = UdpSocketConnectResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.result , r.localAddr , r.receiver );
        break;
      case _udpSocketMethodSetSendBufferSizeName:
        var r = UdpSocketSetSendBufferSizeResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.result );
        break;
      case _udpSocketMethodSetReceiveBufferSizeName:
        var r = UdpSocketSetReceiveBufferSizeResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.result );
        break;
      case _udpSocketMethodNegotiateMaxPendingSendRequestsName:
        var r = UdpSocketNegotiateMaxPendingSendRequestsResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.actualSize );
        break;
      case _udpSocketMethodSendToName:
        var r = UdpSocketSendToResponseParams.deserialize(
            message.payload);
        if (!message.header.hasRequestId) {
          proxyError("Expected a message with a valid request Id.");
          return;
        }
        Function callback = callbackMap[message.header.requestId];
        if (callback == null) {
          proxyError(
              "Message had unknown request Id: ${message.header.requestId}");
          return;
        }
        callbackMap.remove(message.header.requestId);
        callback(r.result );
        break;
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_UdpSocketProxyControl($superString)";
  }
}

class UdpSocketProxy
    extends bindings.Proxy<UdpSocket>
    implements UdpSocket,
               UdpSocketInterface,
               UdpSocketInterfaceRequest {
  UdpSocketProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _UdpSocketProxyControl.fromEndpoint(endpoint));

  UdpSocketProxy.fromHandle(core.MojoHandle handle)
      : super(new _UdpSocketProxyControl.fromHandle(handle));

  UdpSocketProxy.unbound()
      : super(new _UdpSocketProxyControl.unbound());

  factory UdpSocketProxy.fromMock(UdpSocket mock) {
    UdpSocketProxy newMockedProxy =
        new UdpSocketProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static UdpSocketProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For UdpSocketProxy"));
    return new UdpSocketProxy.fromEndpoint(endpoint);
  }


  void allowAddressReuse(void callback(network_error_mojom.NetworkError result)) {
    if (impl != null) {
      impl.allowAddressReuse(callback);
      return;
    }
    var params = new _UdpSocketAllowAddressReuseParams();
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((network_error_mojom.NetworkError result) {
        z.bindCallback(() {
          callback(result);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _udpSocketMethodAllowAddressReuseName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void bind(net_address_mojom.NetAddress addr,void callback(network_error_mojom.NetworkError result, net_address_mojom.NetAddress boundAddr, UdpSocketReceiverInterfaceRequest receiver)) {
    if (impl != null) {
      impl.bind(addr,callback);
      return;
    }
    var params = new _UdpSocketBindParams();
    params.addr = addr;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((network_error_mojom.NetworkError result, net_address_mojom.NetAddress boundAddr, UdpSocketReceiverInterfaceRequest receiver) {
        z.bindCallback(() {
          callback(result, boundAddr, receiver);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _udpSocketMethodBindName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void connect(net_address_mojom.NetAddress remoteAddr,void callback(network_error_mojom.NetworkError result, net_address_mojom.NetAddress localAddr, UdpSocketReceiverInterfaceRequest receiver)) {
    if (impl != null) {
      impl.connect(remoteAddr,callback);
      return;
    }
    var params = new _UdpSocketConnectParams();
    params.remoteAddr = remoteAddr;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((network_error_mojom.NetworkError result, net_address_mojom.NetAddress localAddr, UdpSocketReceiverInterfaceRequest receiver) {
        z.bindCallback(() {
          callback(result, localAddr, receiver);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _udpSocketMethodConnectName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void setSendBufferSize(int size,void callback(network_error_mojom.NetworkError result)) {
    if (impl != null) {
      impl.setSendBufferSize(size,callback);
      return;
    }
    var params = new _UdpSocketSetSendBufferSizeParams();
    params.size = size;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((network_error_mojom.NetworkError result) {
        z.bindCallback(() {
          callback(result);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _udpSocketMethodSetSendBufferSizeName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void setReceiveBufferSize(int size,void callback(network_error_mojom.NetworkError result)) {
    if (impl != null) {
      impl.setReceiveBufferSize(size,callback);
      return;
    }
    var params = new _UdpSocketSetReceiveBufferSizeParams();
    params.size = size;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((network_error_mojom.NetworkError result) {
        z.bindCallback(() {
          callback(result);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _udpSocketMethodSetReceiveBufferSizeName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void negotiateMaxPendingSendRequests(int requestedSize,void callback(int actualSize)) {
    if (impl != null) {
      impl.negotiateMaxPendingSendRequests(requestedSize,callback);
      return;
    }
    var params = new _UdpSocketNegotiateMaxPendingSendRequestsParams();
    params.requestedSize = requestedSize;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((int actualSize) {
        z.bindCallback(() {
          callback(actualSize);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _udpSocketMethodNegotiateMaxPendingSendRequestsName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
  void receiveMore(int datagramNumber) {
    if (impl != null) {
      impl.receiveMore(datagramNumber);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _UdpSocketReceiveMoreParams();
    params.datagramNumber = datagramNumber;
    ctrl.sendMessage(params,
        _udpSocketMethodReceiveMoreName);
  }
  void sendTo(net_address_mojom.NetAddress destAddr,List<int> data,void callback(network_error_mojom.NetworkError result)) {
    if (impl != null) {
      impl.sendTo(destAddr,data,callback);
      return;
    }
    var params = new _UdpSocketSendToParams();
    params.destAddr = destAddr;
    params.data = data;
    Function zonedCallback;
    if (identical(Zone.current, Zone.ROOT)) {
      zonedCallback = callback;
    } else {
      Zone z = Zone.current;
      zonedCallback = ((network_error_mojom.NetworkError result) {
        z.bindCallback(() {
          callback(result);
        })();
      });
    }
    ctrl.sendMessageWithRequestId(
        params,
        _udpSocketMethodSendToName,
        -1,
        bindings.MessageHeader.kMessageExpectsResponse,
        zonedCallback);
  }
}

class _UdpSocketStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<UdpSocket> {
  UdpSocket _impl;

  _UdpSocketStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [UdpSocket impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _UdpSocketStubControl.fromHandle(
      core.MojoHandle handle, [UdpSocket impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _UdpSocketStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => UdpSocket.serviceName;


  Function _udpSocketAllowAddressReuseResponseParamsResponder(
      int requestId) {
  return (network_error_mojom.NetworkError result) {
      var result = new UdpSocketAllowAddressReuseResponseParams();
      result.result = result;
      sendResponse(buildResponseWithId(
          result,
          _udpSocketMethodAllowAddressReuseName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _udpSocketBindResponseParamsResponder(
      int requestId) {
  return (network_error_mojom.NetworkError result, net_address_mojom.NetAddress boundAddr, UdpSocketReceiverInterfaceRequest receiver) {
      var result = new UdpSocketBindResponseParams();
      result.result = result;
      result.boundAddr = boundAddr;
      result.receiver = receiver;
      sendResponse(buildResponseWithId(
          result,
          _udpSocketMethodBindName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _udpSocketConnectResponseParamsResponder(
      int requestId) {
  return (network_error_mojom.NetworkError result, net_address_mojom.NetAddress localAddr, UdpSocketReceiverInterfaceRequest receiver) {
      var result = new UdpSocketConnectResponseParams();
      result.result = result;
      result.localAddr = localAddr;
      result.receiver = receiver;
      sendResponse(buildResponseWithId(
          result,
          _udpSocketMethodConnectName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _udpSocketSetSendBufferSizeResponseParamsResponder(
      int requestId) {
  return (network_error_mojom.NetworkError result) {
      var result = new UdpSocketSetSendBufferSizeResponseParams();
      result.result = result;
      sendResponse(buildResponseWithId(
          result,
          _udpSocketMethodSetSendBufferSizeName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _udpSocketSetReceiveBufferSizeResponseParamsResponder(
      int requestId) {
  return (network_error_mojom.NetworkError result) {
      var result = new UdpSocketSetReceiveBufferSizeResponseParams();
      result.result = result;
      sendResponse(buildResponseWithId(
          result,
          _udpSocketMethodSetReceiveBufferSizeName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _udpSocketNegotiateMaxPendingSendRequestsResponseParamsResponder(
      int requestId) {
  return (int actualSize) {
      var result = new UdpSocketNegotiateMaxPendingSendRequestsResponseParams();
      result.actualSize = actualSize;
      sendResponse(buildResponseWithId(
          result,
          _udpSocketMethodNegotiateMaxPendingSendRequestsName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }
  Function _udpSocketSendToResponseParamsResponder(
      int requestId) {
  return (network_error_mojom.NetworkError result) {
      var result = new UdpSocketSendToResponseParams();
      result.result = result;
      sendResponse(buildResponseWithId(
          result,
          _udpSocketMethodSendToName,
          requestId,
          bindings.MessageHeader.kMessageIsResponse));
    };
  }

  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _udpSocketMethodAllowAddressReuseName:
        _impl.allowAddressReuse(_udpSocketAllowAddressReuseResponseParamsResponder(message.header.requestId));
        break;
      case _udpSocketMethodBindName:
        var params = _UdpSocketBindParams.deserialize(
            message.payload);
        _impl.bind(params.addr, _udpSocketBindResponseParamsResponder(message.header.requestId));
        break;
      case _udpSocketMethodConnectName:
        var params = _UdpSocketConnectParams.deserialize(
            message.payload);
        _impl.connect(params.remoteAddr, _udpSocketConnectResponseParamsResponder(message.header.requestId));
        break;
      case _udpSocketMethodSetSendBufferSizeName:
        var params = _UdpSocketSetSendBufferSizeParams.deserialize(
            message.payload);
        _impl.setSendBufferSize(params.size, _udpSocketSetSendBufferSizeResponseParamsResponder(message.header.requestId));
        break;
      case _udpSocketMethodSetReceiveBufferSizeName:
        var params = _UdpSocketSetReceiveBufferSizeParams.deserialize(
            message.payload);
        _impl.setReceiveBufferSize(params.size, _udpSocketSetReceiveBufferSizeResponseParamsResponder(message.header.requestId));
        break;
      case _udpSocketMethodNegotiateMaxPendingSendRequestsName:
        var params = _UdpSocketNegotiateMaxPendingSendRequestsParams.deserialize(
            message.payload);
        _impl.negotiateMaxPendingSendRequests(params.requestedSize, _udpSocketNegotiateMaxPendingSendRequestsResponseParamsResponder(message.header.requestId));
        break;
      case _udpSocketMethodReceiveMoreName:
        var params = _UdpSocketReceiveMoreParams.deserialize(
            message.payload);
        _impl.receiveMore(params.datagramNumber);
        break;
      case _udpSocketMethodSendToName:
        var params = _UdpSocketSendToParams.deserialize(
            message.payload);
        _impl.sendTo(params.destAddr, params.data, _udpSocketSendToResponseParamsResponder(message.header.requestId));
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  UdpSocket get impl => _impl;
  set impl(UdpSocket d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_UdpSocketStubControl($superString)";
  }

  int get version => 0;
}

class UdpSocketStub
    extends bindings.Stub<UdpSocket>
    implements UdpSocket,
               UdpSocketInterface,
               UdpSocketInterfaceRequest {
  UdpSocketStub.unbound([UdpSocket impl])
      : super(new _UdpSocketStubControl.unbound(impl));

  UdpSocketStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [UdpSocket impl])
      : super(new _UdpSocketStubControl.fromEndpoint(endpoint, impl));

  UdpSocketStub.fromHandle(
      core.MojoHandle handle, [UdpSocket impl])
      : super(new _UdpSocketStubControl.fromHandle(handle, impl));

  static UdpSocketStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For UdpSocketStub"));
    return new UdpSocketStub.fromEndpoint(endpoint);
  }


  void allowAddressReuse(void callback(network_error_mojom.NetworkError result)) {
    return impl.allowAddressReuse(callback);
  }
  void bind(net_address_mojom.NetAddress addr,void callback(network_error_mojom.NetworkError result, net_address_mojom.NetAddress boundAddr, UdpSocketReceiverInterfaceRequest receiver)) {
    return impl.bind(addr,callback);
  }
  void connect(net_address_mojom.NetAddress remoteAddr,void callback(network_error_mojom.NetworkError result, net_address_mojom.NetAddress localAddr, UdpSocketReceiverInterfaceRequest receiver)) {
    return impl.connect(remoteAddr,callback);
  }
  void setSendBufferSize(int size,void callback(network_error_mojom.NetworkError result)) {
    return impl.setSendBufferSize(size,callback);
  }
  void setReceiveBufferSize(int size,void callback(network_error_mojom.NetworkError result)) {
    return impl.setReceiveBufferSize(size,callback);
  }
  void negotiateMaxPendingSendRequests(int requestedSize,void callback(int actualSize)) {
    return impl.negotiateMaxPendingSendRequests(requestedSize,callback);
  }
  void receiveMore(int datagramNumber) {
    return impl.receiveMore(datagramNumber);
  }
  void sendTo(net_address_mojom.NetAddress destAddr,List<int> data,void callback(network_error_mojom.NetworkError result)) {
    return impl.sendTo(destAddr,data,callback);
  }
}

const int _udpSocketReceiverMethodOnReceivedName = 0;

class _UdpSocketReceiverServiceDescription implements service_describer.ServiceDescription {
  void getTopLevelInterface(Function responder) {
    responder(null);
  }

  void getTypeDefinition(String typeKey, Function responder) {
    responder(null);
  }

  void getAllTypeDefinitions(Function responder) {
    responder(null);
  }
}

abstract class UdpSocketReceiver {
  static const String serviceName = null;

  static service_describer.ServiceDescription _cachedServiceDescription;
  static service_describer.ServiceDescription get serviceDescription {
    if (_cachedServiceDescription == null) {
      _cachedServiceDescription = new _UdpSocketReceiverServiceDescription();
    }
    return _cachedServiceDescription;
  }

  static UdpSocketReceiverProxy connectToService(
      bindings.ServiceConnector s, String url, [String serviceName]) {
    UdpSocketReceiverProxy p = new UdpSocketReceiverProxy.unbound();
    String name = serviceName ?? UdpSocketReceiver.serviceName;
    if ((name == null) || name.isEmpty) {
      throw new core.MojoApiError(
          "If an interface has no ServiceName, then one must be provided.");
    }
    s.connectToService(url, p, name);
    return p;
  }
  void onReceived(network_error_mojom.NetworkError result, net_address_mojom.NetAddress srcAddr, List<int> data);
}

abstract class UdpSocketReceiverInterface
    implements bindings.MojoInterface<UdpSocketReceiver>,
               UdpSocketReceiver {
  factory UdpSocketReceiverInterface([UdpSocketReceiver impl]) =>
      new UdpSocketReceiverStub.unbound(impl);

  factory UdpSocketReceiverInterface.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint,
      [UdpSocketReceiver impl]) =>
      new UdpSocketReceiverStub.fromEndpoint(endpoint, impl);

  factory UdpSocketReceiverInterface.fromMock(
      UdpSocketReceiver mock) =>
      new UdpSocketReceiverProxy.fromMock(mock);
}

abstract class UdpSocketReceiverInterfaceRequest
    implements bindings.MojoInterface<UdpSocketReceiver>,
               UdpSocketReceiver {
  factory UdpSocketReceiverInterfaceRequest() =>
      new UdpSocketReceiverProxy.unbound();
}

class _UdpSocketReceiverProxyControl
    extends bindings.ProxyMessageHandler
    implements bindings.ProxyControl<UdpSocketReceiver> {
  UdpSocketReceiver impl;

  _UdpSocketReceiverProxyControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) : super.fromEndpoint(endpoint);

  _UdpSocketReceiverProxyControl.fromHandle(
      core.MojoHandle handle) : super.fromHandle(handle);

  _UdpSocketReceiverProxyControl.unbound() : super.unbound();

  String get serviceName => UdpSocketReceiver.serviceName;

  void handleResponse(bindings.ServiceMessage message) {
    switch (message.header.type) {
      default:
        proxyError("Unexpected message type: ${message.header.type}");
        close(immediate: true);
        break;
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_UdpSocketReceiverProxyControl($superString)";
  }
}

class UdpSocketReceiverProxy
    extends bindings.Proxy<UdpSocketReceiver>
    implements UdpSocketReceiver,
               UdpSocketReceiverInterface,
               UdpSocketReceiverInterfaceRequest {
  UdpSocketReceiverProxy.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint)
      : super(new _UdpSocketReceiverProxyControl.fromEndpoint(endpoint));

  UdpSocketReceiverProxy.fromHandle(core.MojoHandle handle)
      : super(new _UdpSocketReceiverProxyControl.fromHandle(handle));

  UdpSocketReceiverProxy.unbound()
      : super(new _UdpSocketReceiverProxyControl.unbound());

  factory UdpSocketReceiverProxy.fromMock(UdpSocketReceiver mock) {
    UdpSocketReceiverProxy newMockedProxy =
        new UdpSocketReceiverProxy.unbound();
    newMockedProxy.impl = mock;
    return newMockedProxy;
  }

  static UdpSocketReceiverProxy newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For UdpSocketReceiverProxy"));
    return new UdpSocketReceiverProxy.fromEndpoint(endpoint);
  }


  void onReceived(network_error_mojom.NetworkError result, net_address_mojom.NetAddress srcAddr, List<int> data) {
    if (impl != null) {
      impl.onReceived(result, srcAddr, data);
      return;
    }
    if (!ctrl.isBound) {
      ctrl.proxyError("The Proxy is closed.");
      return;
    }
    var params = new _UdpSocketReceiverOnReceivedParams();
    params.result = result;
    params.srcAddr = srcAddr;
    params.data = data;
    ctrl.sendMessage(params,
        _udpSocketReceiverMethodOnReceivedName);
  }
}

class _UdpSocketReceiverStubControl
    extends bindings.StubMessageHandler
    implements bindings.StubControl<UdpSocketReceiver> {
  UdpSocketReceiver _impl;

  _UdpSocketReceiverStubControl.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [UdpSocketReceiver impl])
      : super.fromEndpoint(endpoint, autoBegin: impl != null) {
    _impl = impl;
  }

  _UdpSocketReceiverStubControl.fromHandle(
      core.MojoHandle handle, [UdpSocketReceiver impl])
      : super.fromHandle(handle, autoBegin: impl != null) {
    _impl = impl;
  }

  _UdpSocketReceiverStubControl.unbound([this._impl]) : super.unbound();

  String get serviceName => UdpSocketReceiver.serviceName;



  void handleMessage(bindings.ServiceMessage message) {
    if (bindings.ControlMessageHandler.isControlMessage(message)) {
      bindings.ControlMessageHandler.handleMessage(
          this, 0, message);
      return;
    }
    if (_impl == null) {
      throw new core.MojoApiError("$this has no implementation set");
    }
    switch (message.header.type) {
      case _udpSocketReceiverMethodOnReceivedName:
        var params = _UdpSocketReceiverOnReceivedParams.deserialize(
            message.payload);
        _impl.onReceived(params.result, params.srcAddr, params.data);
        break;
      default:
        throw new bindings.MojoCodecError("Unexpected message name");
        break;
    }
  }

  UdpSocketReceiver get impl => _impl;
  set impl(UdpSocketReceiver d) {
    if (d == null) {
      throw new core.MojoApiError("$this: Cannot set a null implementation");
    }
    if (isBound && (_impl == null)) {
      beginHandlingEvents();
    }
    _impl = d;
  }

  @override
  void bind(core.MojoMessagePipeEndpoint endpoint) {
    super.bind(endpoint);
    if (!isOpen && (_impl != null)) {
      beginHandlingEvents();
    }
  }

  @override
  String toString() {
    var superString = super.toString();
    return "_UdpSocketReceiverStubControl($superString)";
  }

  int get version => 0;
}

class UdpSocketReceiverStub
    extends bindings.Stub<UdpSocketReceiver>
    implements UdpSocketReceiver,
               UdpSocketReceiverInterface,
               UdpSocketReceiverInterfaceRequest {
  UdpSocketReceiverStub.unbound([UdpSocketReceiver impl])
      : super(new _UdpSocketReceiverStubControl.unbound(impl));

  UdpSocketReceiverStub.fromEndpoint(
      core.MojoMessagePipeEndpoint endpoint, [UdpSocketReceiver impl])
      : super(new _UdpSocketReceiverStubControl.fromEndpoint(endpoint, impl));

  UdpSocketReceiverStub.fromHandle(
      core.MojoHandle handle, [UdpSocketReceiver impl])
      : super(new _UdpSocketReceiverStubControl.fromHandle(handle, impl));

  static UdpSocketReceiverStub newFromEndpoint(
      core.MojoMessagePipeEndpoint endpoint) {
    assert(endpoint.setDescription("For UdpSocketReceiverStub"));
    return new UdpSocketReceiverStub.fromEndpoint(endpoint);
  }


  void onReceived(network_error_mojom.NetworkError result, net_address_mojom.NetAddress srcAddr, List<int> data) {
    return impl.onReceived(result, srcAddr, data);
  }
}



