// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_MEDIA_FRAMEWORK_UTIL_FORMATTING_H_
#define SERVICES_MEDIA_FRAMEWORK_UTIL_FORMATTING_H_

#include <ostream>

#include "services/media/framework/models/demand.h"
#include "services/media/framework/packet.h"
#include "services/media/framework/result.h"
#include "services/media/framework/types/audio_stream_type.h"
#include "services/media/framework/types/stream_type.h"
#include "services/media/framework/types/video_stream_type.h"

//
// This file declares a bunch of << operator overloads for dumping media stuff.
// Unless you want to add new operators, it's sufficient to know that you can
// just use the operators as expected, except that some of the overloads can
// produce multiple lines and therefore provide their own newlines.
//
// These operators are intended to be called after a label has been added to
// the stream with a trailing space. If the text generated by an operator is
// sufficiently short, the operator may add that text with no preamble and
// terminate it with std::endl. If the text has to be multiline, the operator
// first adds std::endl, then the multiline text with std::endl termination.
// Each line starts with begl in order to apply the appropriate indentation.
// The Indenter class is provided to adjust the identation level. Operators
// that take pointers need to handle nullptr.
//

namespace mojo {
namespace media {

int ostream_indent_index();

std::ostream& begl(std::ostream& os);

inline std::ostream& indent(std::ostream& os) {
  ++os.iword(ostream_indent_index());
  return os;
}

inline std::ostream& outdent(std::ostream& os) {
  --os.iword(ostream_indent_index());
  return os;
}

// The following overloads don't add newlines.

std::ostream& operator<<(std::ostream& os, Result value);
std::ostream& operator<<(std::ostream& os, Demand value);
std::ostream& operator<<(std::ostream& os, const PacketPtr& value);
std::ostream& operator<<(std::ostream& os, StreamType::Medium value);
std::ostream& operator<<(std::ostream& os, AudioStreamType::SampleFormat value);
std::ostream& operator<<(std::ostream& os, VideoStreamType::VideoProfile value);
std::ostream& operator<<(std::ostream& os, VideoStreamType::PixelFormat value);
std::ostream& operator<<(std::ostream& os, VideoStreamType::ColorSpace value);
std::ostream& operator<<(std::ostream& os, const std::unique_ptr<Bytes>& value);

template <typename T>
std::ostream& operator<<(std::ostream& os, Range<T> value) {
  return os << value.min << ".." << value.max;
}

std::ostream& operator<<(std::ostream& os, Range<bool> value);

// The following overloads add newlines.

std::ostream& operator<<(std::ostream& os,
                         const std::unique_ptr<StreamType>& value);
std::ostream& operator<<(std::ostream& os,
                         const std::unique_ptr<StreamTypeSet>& value);
std::ostream& operator<<(
    std::ostream& os,
    const std::unique_ptr<std::vector<std::unique_ptr<StreamType>>>& value);
std::ostream& operator<<(
    std::ostream& os,
    const std::unique_ptr<std::vector<std::unique_ptr<StreamTypeSet>>>& value);

template <typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& value) {
  if (value.size() == 0) {
    return os << "<empty>" << std::endl;
  } else {
    os << std::endl;
  }

  int index = 0;
  for (const T& element : value) {
    os << begl << "[" << index++ << "] " << element;
  }

  return os;
}

}  // namespace media
}  // namespace mojo

#endif  // SERVICES_MEDIA_FRAMEWORK_UTIL_FORMATTING_H_
